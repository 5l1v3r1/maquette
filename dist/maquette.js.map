{"version":3,"sources":["maquette.js","../../../src/maquette.ts"],"names":["NAMESPACE_SVG","emptyArray","extend","base","overrides","result","Object","keys","forEach","key","same","vnode1","vnode2","vnodeSelector","properties","bind","toTextVNode","data","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectionOptions","checkStyleValue","styleValue","setProperties","propNames","propCount","propName","propValue","className","classNames","classNameCount","j","classList","add","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","target","apply","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","createDom","updateDom","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","c","found","document","createTextNode","appendChild","charAt","slice","id","createElementNS","createElement","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","exports","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","append","beforeNode","merge","element","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","originalEventHandlerInterceptor","propertyName","eventHandler","scheduleRenderAndInvokeEventHandler","scheduleRender","renderCompleted","scheduled","stopped","projections","renderFunctions","doRender","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","replace"],"mappings":"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","file":"maquette.js","sourcesContent":["// Comment that is displayed in the API documentation for the maquette module:\n/**\n * Welcome to the API documentation of the **maquette** library.\n *\n * [[http://maquettejs.org/|To the maquette homepage]]\n */\n\"use strict\";\n;\n;\n;\nvar NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\n// Utilities\nvar emptyArray = [];\nvar extend = function (base, overrides) {\n    var result = {};\n    Object.keys(base).forEach(function (key) {\n        result[key] = base[key];\n    });\n    if (overrides) {\n        Object.keys(overrides).forEach(function (key) {\n            result[key] = overrides[key];\n        });\n    }\n    return result;\n};\n// Hyperscript helper functions\nvar same = function (vnode1, vnode2) {\n    if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n        return false;\n    }\n    if (vnode1.properties && vnode2.properties) {\n        if (vnode1.properties.key !== vnode2.properties.key) {\n            return false;\n        }\n        return vnode1.properties.bind === vnode2.properties.bind;\n    }\n    return !vnode1.properties && !vnode2.properties;\n};\nvar toTextVNode = function (data) {\n    return {\n        vnodeSelector: '',\n        properties: undefined,\n        children: undefined,\n        text: data.toString(),\n        domNode: null\n    };\n};\nvar appendChildren = function (parentSelector, insertions, main) {\n    for (var i = 0; i < insertions.length; i++) {\n        var item = insertions[i];\n        if (Array.isArray(item)) {\n            appendChildren(parentSelector, item, main);\n        }\n        else {\n            if (item !== null && item !== undefined) {\n                if (!item.hasOwnProperty('vnodeSelector')) {\n                    item = toTextVNode(item);\n                }\n                main.push(item);\n            }\n        }\n    }\n};\n// Render helper functions\nvar missingTransition = function () {\n    throw new Error('Provide a transitions object to the projectionOptions to do animations');\n};\nvar DEFAULT_PROJECTION_OPTIONS = {\n    namespace: undefined,\n    eventHandlerInterceptor: undefined,\n    styleApplyer: function (domNode, styleName, value) {\n        // Provides a hook to add vendor prefixes for browsers that still need it.\n        domNode.style[styleName] = value;\n    },\n    transitions: {\n        enter: missingTransition,\n        exit: missingTransition\n    }\n};\nvar applyDefaultProjectionOptions = function (projectionOptions) {\n    return extend(DEFAULT_PROJECTION_OPTIONS, projectionOptions);\n};\nvar checkStyleValue = function (styleValue) {\n    if (typeof styleValue !== 'string') {\n        throw new Error('Style values must be strings');\n    }\n};\nvar setProperties = function (domNode, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    for (var i = 0; i < propCount; i++) {\n        var propName = propNames[i];\n        /* tslint:disable:no-var-keyword: edge case */\n        var propValue = properties[propName];\n        /* tslint:enable:no-var-keyword */\n        if (propName === 'className') {\n            throw new Error('Property \"className\" is not supported, use \"class\".');\n        }\n        else if (propName === 'class') {\n            if (domNode.className) {\n                // May happen if classes is specified before class\n                domNode.className += ' ' + propValue;\n            }\n            else {\n                domNode.className = propValue;\n            }\n        }\n        else if (propName === 'classes') {\n            // object with string keys and boolean values\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                if (propValue[className]) {\n                    domNode.classList.add(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            // object with string keys and string (!) values\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var styleValue = propValue[styleName];\n                if (styleValue) {\n                    checkStyleValue(styleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                }\n            }\n        }\n        else if (propName === 'key') {\n            continue;\n        }\n        else if (propValue === null || propValue === undefined) {\n            continue;\n        }\n        else {\n            var type = typeof propValue;\n            if (type === 'function') {\n                if (eventHandlerInterceptor && (propName.lastIndexOf('on', 0) === 0)) {\n                    propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n                    if (propName === 'oninput') {\n                        (function () {\n                            // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\n                            var oldPropValue = propValue;\n                            propValue = function (evt) {\n                                evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well\n                                oldPropValue.apply(this, [evt]);\n                            };\n                        }());\n                    }\n                    domNode[propName] = propValue;\n                }\n            }\n            else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                domNode.setAttribute(propName, propValue);\n            }\n            else {\n                domNode[propName] = propValue;\n            }\n        }\n    }\n};\nvar updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var propertiesUpdated = false;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    for (var i = 0; i < propCount; i++) {\n        var propName = propNames[i];\n        // assuming that properties will be nullified instead of missing is by design\n        var propValue = properties[propName];\n        var previousValue = previousProperties[propName];\n        if (propName === 'class') {\n            if (previousValue !== propValue) {\n                throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n            }\n        }\n        else if (propName === 'classes') {\n            var classList = domNode.classList;\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                var on = !!propValue[className];\n                var previousOn = !!previousValue[className];\n                if (on === previousOn) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (on) {\n                    classList.add(className);\n                }\n                else {\n                    classList.remove(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var newStyleValue = propValue[styleName];\n                var oldStyleValue = previousValue[styleName];\n                if (newStyleValue === oldStyleValue) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (newStyleValue) {\n                    checkStyleValue(newStyleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                }\n                else {\n                    projectionOptions.styleApplyer(domNode, styleName, '');\n                }\n            }\n        }\n        else {\n            if (!propValue && typeof previousValue === 'string') {\n                propValue = '';\n            }\n            if (propName === 'value') {\n                if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                    domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n                    domNode['oninput-value'] = undefined;\n                } // else do not update the domNode, otherwise the cursor position would be changed\n                if (propValue !== previousValue) {\n                    propertiesUpdated = true;\n                }\n            }\n            else if (propValue !== previousValue) {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\n                        '). Hint: declare event handler functions outside the render() function.');\n                }\n                if (type === 'string' && propName !== 'innerHTML') {\n                    domNode.setAttribute(propName, propValue);\n                }\n                else {\n                    if (domNode[propName] !== propValue) {\n                        domNode[propName] = propValue;\n                    }\n                }\n                propertiesUpdated = true;\n            }\n        }\n    }\n    return propertiesUpdated;\n};\nvar findIndexOfChild = function (children, sameAs, start) {\n    if (sameAs.vnodeSelector !== '') {\n        // Never scan for text-nodes\n        for (var i = start; i < children.length; i++) {\n            if (same(children[i], sameAs)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\nvar nodeAdded = function (vNode, transitions) {\n    if (vNode.properties) {\n        var enterAnimation = vNode.properties.enterAnimation;\n        if (enterAnimation) {\n            if (typeof enterAnimation === 'function') {\n                enterAnimation(vNode.domNode, vNode.properties);\n            }\n            else {\n                transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n            }\n        }\n    }\n};\nvar nodeToRemove = function (vNode, transitions) {\n    var domNode = vNode.domNode;\n    if (vNode.properties) {\n        var exitAnimation = vNode.properties.exitAnimation;\n        if (exitAnimation) {\n            domNode.style.pointerEvents = 'none';\n            var removeDomNode = function () {\n                if (domNode.parentNode) {\n                    domNode.parentNode.removeChild(domNode);\n                }\n            };\n            if (typeof exitAnimation === 'function') {\n                exitAnimation(domNode, removeDomNode, vNode.properties);\n                return;\n            }\n            else {\n                transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                return;\n            }\n        }\n    }\n    if (domNode.parentNode) {\n        domNode.parentNode.removeChild(domNode);\n    }\n};\nvar checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n    var childNode = childNodes[indexToCheck];\n    if (childNode.vnodeSelector === '') {\n        return; // Text nodes need not be distinguishable\n    }\n    var key = childNode.properties ? (childNode.properties.key || childNode.properties.bind) : undefined;\n    if (!key) {\n        for (var i = 0; i < childNodes.length; i++) {\n            if (i !== indexToCheck) {\n                var node = childNodes[i];\n                if (same(node, childNode)) {\n                    if (operation === 'added') {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                    else {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                }\n            }\n        }\n    }\n};\nvar createDom;\nvar updateDom;\nvar updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n    if (oldChildren === newChildren) {\n        return false;\n    }\n    oldChildren = oldChildren || emptyArray;\n    newChildren = newChildren || emptyArray;\n    var oldChildrenLength = oldChildren.length;\n    var newChildrenLength = newChildren.length;\n    var transitions = projectionOptions.transitions;\n    var oldIndex = 0;\n    var newIndex = 0;\n    var i;\n    var textUpdated = false;\n    while (newIndex < newChildrenLength) {\n        var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\n        var newChild = newChildren[newIndex];\n        if (oldChild !== undefined && same(oldChild, newChild)) {\n            textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n            oldIndex++;\n        }\n        else {\n            var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n            if (findOldIndex >= 0) {\n                // Remove preceding missing children\n                for (i = oldIndex; i < findOldIndex; i++) {\n                    nodeToRemove(oldChildren[i], transitions);\n                    checkDistinguishable(oldChildren, i, vnode, 'removed');\n                }\n                textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                oldIndex = findOldIndex + 1;\n            }\n            else {\n                // New child\n                createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                nodeAdded(newChild, transitions);\n                checkDistinguishable(newChildren, newIndex, vnode, 'added');\n            }\n        }\n        newIndex++;\n    }\n    if (oldChildrenLength > oldIndex) {\n        // Remove child fragments\n        for (i = oldIndex; i < oldChildrenLength; i++) {\n            nodeToRemove(oldChildren[i], transitions);\n            checkDistinguishable(oldChildren, i, vnode, 'removed');\n        }\n    }\n    return textUpdated;\n};\nvar addChildren = function (domNode, children, projectionOptions) {\n    if (!children) {\n        return;\n    }\n    for (var i = 0; i < children.length; i++) {\n        createDom(children[i], domNode, undefined, projectionOptions);\n    }\n};\nvar initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n    addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n    if (vnode.text) {\n        domNode.textContent = vnode.text;\n    }\n    setProperties(domNode, vnode.properties, projectionOptions);\n    if (vnode.properties && vnode.properties.afterCreate) {\n        vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n    }\n};\ncreateDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n    var domNode, i, c, start = 0, type, found;\n    var vnodeSelector = vnode.vnodeSelector;\n    if (vnodeSelector === '') {\n        domNode = vnode.domNode = document.createTextNode(vnode.text);\n        if (insertBefore !== undefined) {\n            parentNode.insertBefore(domNode, insertBefore);\n        }\n        else {\n            parentNode.appendChild(domNode);\n        }\n    }\n    else {\n        for (i = 0; i <= vnodeSelector.length; ++i) {\n            c = vnodeSelector.charAt(i);\n            if (i === vnodeSelector.length || c === '.' || c === '#') {\n                type = vnodeSelector.charAt(start - 1);\n                found = vnodeSelector.slice(start, i);\n                if (type === '.') {\n                    domNode.classList.add(found);\n                }\n                else if (type === '#') {\n                    domNode.id = found;\n                }\n                else {\n                    if (found === 'svg') {\n                        projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                    }\n                    if (projectionOptions.namespace !== undefined) {\n                        domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                    }\n                    else {\n                        domNode = vnode.domNode = document.createElement(found);\n                    }\n                    if (insertBefore !== undefined) {\n                        parentNode.insertBefore(domNode, insertBefore);\n                    }\n                    else {\n                        parentNode.appendChild(domNode);\n                    }\n                }\n                start = i + 1;\n            }\n        }\n        initPropertiesAndChildren(domNode, vnode, projectionOptions);\n    }\n};\nupdateDom = function (previous, vnode, projectionOptions) {\n    var domNode = previous.domNode;\n    var textUpdated = false;\n    if (previous === vnode) {\n        return textUpdated; // By contract, VNode objects may not be modified after passing them to maquette\n    }\n    var updated = false;\n    if (vnode.vnodeSelector === '') {\n        if (vnode.text !== previous.text) {\n            var newVNode = document.createTextNode(vnode.text);\n            domNode.parentNode.replaceChild(newVNode, domNode);\n            vnode.domNode = newVNode;\n            textUpdated = true;\n            return textUpdated;\n        }\n    }\n    else {\n        if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n        }\n        if (previous.text !== vnode.text) {\n            updated = true;\n            if (vnode.text === undefined) {\n                domNode.removeChild(domNode.firstChild); // the only textnode presumably\n            }\n            else {\n                domNode.textContent = vnode.text;\n            }\n        }\n        updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n        updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n        if (vnode.properties && vnode.properties.afterUpdate) {\n            vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n        }\n    }\n    if (updated && vnode.properties && vnode.properties.updateAnimation) {\n        vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n    }\n    vnode.domNode = previous.domNode;\n    return textUpdated;\n};\nvar createProjection = function (vnode, projectionOptions) {\n    return {\n        update: function (updatedVnode) {\n            if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n            }\n            updateDom(vnode, updatedVnode, projectionOptions);\n            vnode = updatedVnode;\n        },\n        domNode: vnode.domNode\n    };\n};\n;\n// The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\nexports.h = function (selector) {\n    var properties = arguments[1];\n    if (typeof selector !== 'string') {\n        throw new Error();\n    }\n    var childIndex = 1;\n    if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n        childIndex = 2;\n    }\n    else {\n        // Optional properties argument was omitted\n        properties = undefined;\n    }\n    var text = undefined;\n    var children = undefined;\n    var argsLength = arguments.length;\n    // Recognize a common special case where there is only a single text node\n    if (argsLength === childIndex + 1) {\n        var onlyChild = arguments[childIndex];\n        if (typeof onlyChild === 'string') {\n            text = onlyChild;\n        }\n        else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n            text = onlyChild[0];\n        }\n    }\n    if (text === undefined) {\n        children = [];\n        for (; childIndex < arguments.length; childIndex++) {\n            var child = arguments[childIndex];\n            if (child === null || child === undefined) {\n                continue;\n            }\n            else if (Array.isArray(child)) {\n                appendChildren(selector, child, children);\n            }\n            else if (child.hasOwnProperty('vnodeSelector')) {\n                children.push(child);\n            }\n            else {\n                children.push(toTextVNode(child));\n            }\n        }\n    }\n    return {\n        vnodeSelector: selector,\n        properties: properties,\n        children: children,\n        text: text,\n        domNode: null\n    };\n};\n/**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\nexports.dom = {\n    /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n    create: function (vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n    append: function (parentNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, parentNode, undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    insertBefore: function (beforeNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    merge: function (element, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        vnode.domNode = element;\n        initPropertiesAndChildren(element, vnode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    }\n};\n/**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\nexports.createCache = function () {\n    var cachedInputs = undefined;\n    var cachedOutcome = undefined;\n    var result = {\n        invalidate: function () {\n            cachedOutcome = undefined;\n            cachedInputs = undefined;\n        },\n        result: function (inputs, calculation) {\n            if (cachedInputs) {\n                for (var i = 0; i < inputs.length; i++) {\n                    if (cachedInputs[i] !== inputs[i]) {\n                        cachedOutcome = undefined;\n                    }\n                }\n            }\n            if (!cachedOutcome) {\n                cachedOutcome = calculation();\n                cachedInputs = inputs;\n            }\n            return cachedOutcome;\n        }\n    };\n    return result;\n};\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\nexports.createMapping = function (getSourceKey, createResult, updateResult) {\n    var keys = [];\n    var results = [];\n    return {\n        results: results,\n        map: function (newSources) {\n            var newKeys = newSources.map(getSourceKey);\n            var oldTargets = results.slice();\n            var oldIndex = 0;\n            for (var i = 0; i < newSources.length; i++) {\n                var source = newSources[i];\n                var sourceKey = newKeys[i];\n                if (sourceKey === keys[oldIndex]) {\n                    results[i] = oldTargets[oldIndex];\n                    updateResult(source, oldTargets[oldIndex], i);\n                    oldIndex++;\n                }\n                else {\n                    var found = false;\n                    for (var j = 1; j < keys.length; j++) {\n                        var searchIndex = (oldIndex + j) % keys.length;\n                        if (keys[searchIndex] === sourceKey) {\n                            results[i] = oldTargets[searchIndex];\n                            updateResult(newSources[i], oldTargets[searchIndex], i);\n                            oldIndex = searchIndex + 1;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        results[i] = createResult(source, i);\n                    }\n                }\n            }\n            results.length = newSources.length;\n            keys = newKeys;\n        }\n    };\n};\n/**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\nexports.createProjector = function (projectionOptions) {\n    var projector;\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    var originalEventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n    projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n        var scheduleRenderAndInvokeEventHandler = function () {\n            // intercept function calls (event handlers) to do a render afterwards.\n            projector.scheduleRender();\n            return eventHandler.apply(properties.bind || this, arguments);\n        };\n        if (originalEventHandlerInterceptor) {\n            return originalEventHandlerInterceptor(propertyName, scheduleRenderAndInvokeEventHandler, domNode, properties);\n        }\n        else {\n            return scheduleRenderAndInvokeEventHandler;\n        }\n    };\n    var renderCompleted = true;\n    var scheduled;\n    var stopped = false;\n    var projections = [];\n    var renderFunctions = []; // matches the projections array\n    var doRender = function () {\n        scheduled = undefined;\n        if (!renderCompleted) {\n            return; // The last render threw an error, it should be logged in the browser console.\n        }\n        renderCompleted = false;\n        for (var i = 0; i < projections.length; i++) {\n            var updatedVnode = renderFunctions[i]();\n            projections[i].update(updatedVnode);\n        }\n        renderCompleted = true;\n    };\n    projector = {\n        scheduleRender: function () {\n            if (!scheduled && !stopped) {\n                scheduled = requestAnimationFrame(doRender);\n            }\n        },\n        stop: function () {\n            if (scheduled) {\n                cancelAnimationFrame(scheduled);\n                scheduled = undefined;\n            }\n            stopped = true;\n        },\n        resume: function () {\n            stopped = false;\n            renderCompleted = true;\n            projector.scheduleRender();\n        },\n        append: function (parentNode, renderMaquetteFunction) {\n            projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        insertBefore: function (beforeNode, renderMaquetteFunction) {\n            projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        merge: function (domNode, renderMaquetteFunction) {\n            projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        replace: function (domNode, renderMaquetteFunction) {\n            var vnode = renderMaquetteFunction();\n            createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n            domNode.parentNode.removeChild(domNode);\n            projections.push(createProjection(vnode, projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        }\n    };\n    return projector;\n};\n\n//# sourceMappingURL=maquette.js.map\n","// Comment that is displayed in the API documentation for the maquette module:\r\n/**\r\n * Welcome to the API documentation of the **maquette** library.\r\n *\r\n * [[http://maquettejs.org/|To the maquette homepage]]\r\n */\r\n\r\n/**\r\n * A virtual representation of a DOM Node. Maquette assumes that [[VNode]] objects are never modified externally.\r\n * Instances of [[VNode]] can be created using [[h]].\r\n */\r\nexport interface VNode {\r\n  /**\r\n   * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node.\r\n   */\r\n  vnodeSelector: string;\r\n  /**\r\n   * Object containing attributes, properties, event handlers and more, see [[h]].\r\n   */\r\n  properties: VNodeProperties;\r\n  /**\r\n   * Array of [[VNode]]s to be used as children. This array is already flattened.\r\n   */\r\n  children: Array<VNode>;\r\n  /**\r\n   * Used in a special case when a [[VNode]] only has one childnode which is a textnode. Only used in combination with children === undefined.\r\n   */\r\n  text: string;\r\n  /**\r\n   * Used by maquette to store the domNode that was produced from this [[VNode]].\r\n   */\r\n  domNode: Node;\r\n}\r\n\r\n/**\r\n * A projector is used to create the real DOM from the the virtual DOM and to keep it up-to-date afterwards.\r\n *\r\n * You can call [[append]], [[merge]], [[insertBefore]] and [[replace]] to add the virtual DOM to the real DOM.\r\n * The `renderMaquetteFunction` callbacks will be called to create the real DOM immediately.\r\n * Afterwards, the `renderMaquetteFunction` callbacks will be called again to update the DOM on the next animation-frame after:\r\n *\r\n *  - The Projector's [[scheduleRender]] function  was called\r\n *  - An event handler (like `onclick`) on a rendered [[VNode]] was called.\r\n *\r\n * The projector stops when [[stop]] is called or when an error is thrown during rendering.\r\n * It is possible to use `window.onerror` to handle these errors.\r\n * Instances of [[Projector]] can be created using [[createProjector]].\r\n */\r\nexport interface Projector {\r\n  /**\r\n   * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\r\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n   * @param parentNode - The parent node for the new childNode.\r\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\r\n   */\r\n  append(parentNode: Element, renderMaquetteFunction: () => VNode): void;\r\n  /**\r\n   * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\r\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n   * @param beforeNode - The node that the DOM Node is inserted before.\r\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\r\n   */\r\n  insertBefore(beforeNode: Element, renderMaquetteFunction: () => VNode): void;\r\n  /**\r\n   * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\r\n   * This means that the virtual DOM and real DOM have one overlapping element.\r\n   * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided\r\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n   * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\r\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\r\n   */\r\n  merge(domNode: Element, renderMaquetteFunction: () => VNode): void;\r\n  /**\r\n   * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\r\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n   * @param domNode - The DOM node to replace.\r\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\r\n   */\r\n  replace(domNode: Element, renderMaquetteFunction: () => VNode): void;\r\n  /**\r\n   * Resumes the projector. Use this method to resume rendering after [[stop]] was called or an error occurred during rendering.\r\n   */\r\n  resume(): void;\r\n  /**\r\n   * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\r\n   * This method is automatically called for you when event-handlers that are registered in the [[VNode]]s are invoked.\r\n   *\r\n   * You need to call this method when timeouts expire, when AJAX responses arrive or other asynchronous actions happen.\r\n   */\r\n  scheduleRender(): void;\r\n  /**\r\n   * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\r\n   *\r\n   * Note that calling [[stop]] is not mandatory. A projector is a passive object that will get garbage collected\r\n   * as usual if it is no longer in scope.\r\n   */\r\n  stop(): void;\r\n}\r\n\r\n/**\r\n * These functions are called when [[VNodeProperties.enterAnimation]] and [[VNodeProperties.exitAnimation]] are provided as strings.\r\n * See [[ProjectionOptions.transitions]].\r\n */\r\nexport interface TransitionStrategy {\r\n  /**\r\n   * Function that is called when a [[VNode]] with an `enterAnimation` string is added to an already existing parent [[VNode]].\r\n   *\r\n   * @param element         Element that was just added to the DOM.\r\n   * @param properties      The properties object that was supplied to the [[h]] method\r\n   * @param enterAnimation  The string that was passed to [[VNodeProperties.enterAnimation]].\r\n   */\r\n  enter(element: Element, properties: VNodeProperties, enterAnimation: string): void;\r\n  /**\r\n   * Function that is called when a [[VNode]] with an `exitAnimation` string is removed from a existing parent [[VNode]] that remains.\r\n   *\r\n   * @param element         Element that ought to be removed from to the DOM.\r\n   * @param properties      The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\r\n   * @param exitAnimation   The string that was passed to [[VNodeProperties.exitAnimation]].\r\n   * @param removeElement   Function that removes the element from the DOM.\r\n   *                        This argument is provided purely for convenience.\r\n   *                        You may use this function to remove the element when the animation is done.\r\n   */\r\n  exit(element: Element, properties: VNodeProperties, exitAnimation: string, removeElement: () => void): void;\r\n};\r\n\r\n/**\r\n * Options that influence how the DOM is rendered and updated.\r\n */\r\nexport interface ProjectionOptions {\r\n  /**\r\n   * A transition strategy to invoke when enterAnimation and exitAnimation properties are provided as strings.\r\n   * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\r\n   * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\r\n   */\r\n  transitions?: TransitionStrategy;\r\n  /**\r\n   * Only for internal use. Used for rendering SVG Nodes.\r\n   */\r\n  namespace?: string;\r\n  /**\r\n   * May be used to intercept registration of event-handlers.\r\n   *\r\n   * Used by the [[Projector]] to wrap eventHandler-calls to call [[scheduleRender]] as well.\r\n   *\r\n   * @param propertyName             The name of the property to be assigned, for example onclick\r\n   * @param eventHandler             The function that was registered on the [[VNode]]\r\n   * @param domNode                  The real DOM element\r\n   * @param properties               The whole set of properties that was put on the VNode\r\n   * @returns                        The function that is to be placed on the DOM node as the event handler, instead of `eventHandler`.\r\n   */\r\n  eventHandlerInterceptor?: (propertyName: string, eventHandler: Function, domNode: Node, properties: VNodeProperties) => Function;\r\n  /**\r\n   * May be used to add vendor prefixes when applying inline styles when needed.\r\n   * This function is called when [[styles]] is used.\r\n   * This function should execute `domNode.style[styleName] = value` or do something smarter.\r\n   *\r\n   * @param domNode   The DOM Node that needs to receive the style\r\n   * @param styleName The name of the style that should be applied, for example `transform`.\r\n   * @param value     The value of this style, for example `rotate(45deg)`.\r\n   */\r\n  styleApplyer?(domNode: HTMLElement, styleName: string, value: string): void;\r\n};\r\n\r\n/**\r\n * Object containing attributes, properties, event handlers and more that can be put on DOM nodes.\r\n *\r\n * For your convenience, all common attributes, properties and event handlers are listed here and are\r\n * type-checked when using Typescript.\r\n */\r\nexport interface VNodeProperties {\r\n  /**\r\n   * The animation to perform when this node is added to an already existing parent.\r\n   * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the\r\n   * projector using [[createProjector]].\r\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n   * @param element - Element that was just added to the DOM.\r\n   * @param properties - The properties object that was supplied to the [[h]] method\r\n   */\r\n  enterAnimation?: ((element: Element, properties?: VNodeProperties) => void) | string;\r\n  /**\r\n   * The animation to perform when this node is removed while its parent remains.\r\n   * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector using [[createProjector]].\r\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n   * @param element - Element that ought to be removed from to the DOM.\r\n   * @param removeElement - Function that removes the element from the DOM.\r\n   * This argument is provided purely for convenience.\r\n   * You may use this function to remove the element when the animation is done.\r\n   * @param properties - The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\r\n   */\r\n  exitAnimation?: ((element: Element, removeElement: () => void, properties?: VNodeProperties) => void) | string;\r\n  /**\r\n   * The animation to perform when the properties of this node change.\r\n   * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\r\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n   * @param element - Element that was modified in the DOM.\r\n   * @param properties - The last properties object that was supplied to the [[h]] method\r\n   * @param previousProperties - The previous properties object that was supplied to the [[h]] method\r\n   */\r\n  updateAnimation?: (element: Element, properties?: VNodeProperties, previousProperties?: VNodeProperties) => void;\r\n  /**\r\n   * Callback that is executed after this node is added to the DOM. Childnodes and properties have\r\n   * already been applied.\r\n   * @param element - The element that was added to the DOM.\r\n   * @param projectionOptions - The projection options that were used see [[createProjector]].\r\n   * @param vnodeSelector - The selector passed to the [[h]] function.\r\n   * @param properties - The properties passed to the [[h]] function.\r\n   * @param children - The children that were created.\r\n   * @param properties - The last properties object that was supplied to the [[h]] method\r\n   * @param previousProperties - The previous properties object that was supplied to the [[h]] method\r\n   */\r\n  afterCreate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\r\n    children: VNode[]): void;\r\n  /**\r\n   * Callback that is executed every time this node may have been updated. Childnodes and properties\r\n   * have already been updated.\r\n   * @param element - The element that may have been updated in the DOM.\r\n   * @param projectionOptions - The projection options that were used see [[createProjector]].\r\n   * @param vnodeSelector - The selector passed to the [[h]] function.\r\n   * @param properties - The properties passed to the [[h]] function.\r\n   * @param children - The children for this node.\r\n   */\r\n  afterUpdate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\r\n    children: VNode[]): void;\r\n  /**\r\n   * When specified, the event handlers will be invoked with 'this' pointing to the value.\r\n   * This is useful when using the prototype/class based implementation of Components.\r\n   *\r\n   * When no [[key]] is present, this object is also used to uniquely identify a DOM node.\r\n   */\r\n  bind?: Object;\r\n  /**\r\n   * Used to uniquely identify a DOM node among siblings.\r\n   * A key is required when there are more children with the same selector and these children are added or removed dynamically.\r\n   * NOTE: this does not have to be a string or number, a [[Component]] Object for instance is also possible.\r\n   */\r\n  key?: Object;\r\n  /**\r\n   * An object literal like `{important:true}` which allows css classes, like `important` to be added and removed\r\n   * dynamically.\r\n   */\r\n  classes?: { [index: string]: boolean };\r\n  /**\r\n   * An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\r\n   */\r\n  styles?: { [index: string]: string };\r\n\r\n  // From Element\r\n  ontouchcancel?(ev?: TouchEvent): boolean | void;\r\n  ontouchend?(ev?: TouchEvent): boolean | void;\r\n  ontouchmove?(ev?: TouchEvent): boolean | void;\r\n  ontouchstart?(ev?: TouchEvent): boolean | void;\r\n  // From HTMLFormElement\r\n  action?: string;\r\n  encoding?: string;\r\n  enctype?: string;\r\n  method?: string;\r\n  name?: string;\r\n  target?: string;\r\n  // From HTMLElement\r\n  onblur?(ev?: FocusEvent): boolean | void;\r\n  onchange?(ev?: Event): boolean | void;\r\n  onclick?(ev?: MouseEvent): boolean | void;\r\n  ondblclick?(ev?: MouseEvent): boolean | void;\r\n  onfocus?(ev?: FocusEvent): boolean | void;\r\n  oninput?(ev?: Event): boolean | void;\r\n  onkeydown?(ev?: KeyboardEvent): boolean | void;\r\n  onkeypress?(ev?: KeyboardEvent): boolean | void;\r\n  onkeyup?(ev?: KeyboardEvent): boolean | void;\r\n  onload?(ev?: Event): boolean | void;\r\n  onmousedown?(ev?: MouseEvent): boolean | void;\r\n  onmouseenter?(ev?: MouseEvent): boolean | void;\r\n  onmouseleave?(ev?: MouseEvent): boolean | void;\r\n  onmousemove?(ev?: MouseEvent): boolean | void;\r\n  onmouseout?(ev?: MouseEvent): boolean | void;\r\n  onmouseover?(ev?: MouseEvent): boolean | void;\r\n  onmouseup?(ev?: MouseEvent): boolean | void;\r\n  onmousewheel?(ev?: MouseWheelEvent): boolean | void;\r\n  onscroll?(ev?: UIEvent): boolean | void;\r\n  onsubmit?(ev?: Event): boolean | void;\r\n  spellcheck?: boolean;\r\n  tabIndex?: number;\r\n  title?: string;\r\n  accessKey?: string;\r\n  id?: string;\r\n  // From HTMLInputElement\r\n  autocomplete?: string;\r\n  checked?: boolean;\r\n  placeholder?: string;\r\n  readOnly?: boolean;\r\n  src?: string;\r\n  value?: string;\r\n  // From HTMLImageElement\r\n  alt?: string;\r\n  srcset?: string;\r\n  /**\r\n   * Puts a non-interactive piece of html inside the DOM node.\r\n   *\r\n   * Note: if you use innerHTML, maquette cannot protect you from XSS vulnerabilities and you must make sure that the innerHTML value is safe.\r\n   */\r\n  innerHTML?: string;\r\n\r\n  /**\r\n   * Everything that is not explicitly listed (properties and attributes that are either uncommon or custom).\r\n   */\r\n  [index: string]: any;\r\n};\r\n\r\n/**\r\n * Represents a [[VNode]] tree that has been rendered to a real DOM tree.\r\n */\r\nexport interface Projection {\r\n  /**\r\n   * The DOM node that is used as the root of this [[Projection]].\r\n   */\r\n  domNode: Element;\r\n  /**\r\n   * Updates the real DOM to match the new virtual DOM tree.\r\n   * @param updatedVnode The updated virtual DOM tree. Note: The selector for the root of the [[VNode]] tree may not change.\r\n   */\r\n  update(updatedVnode: VNode): void;\r\n}\r\n\r\nconst NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\r\n\r\n// Utilities\r\n\r\nlet emptyArray = <VNode[]>[];\r\n\r\nlet extend = <T>(base: T, overrides: any): T => {\r\n  let result = {} as any;\r\n  Object.keys(base).forEach(function(key) {\r\n    result[key] = (base as any)[key];\r\n  });\r\n  if (overrides) {\r\n    Object.keys(overrides).forEach((key) => {\r\n      result[key] = overrides[key];\r\n    });\r\n  }\r\n  return result;\r\n};\r\n\r\n// Hyperscript helper functions\r\n\r\nlet same = (vnode1: VNode, vnode2: VNode) => {\r\n  if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\r\n    return false;\r\n  }\r\n  if (vnode1.properties && vnode2.properties) {\r\n    if (vnode1.properties.key !== vnode2.properties.key) {\r\n      return false;\r\n    }\r\n    return vnode1.properties.bind === vnode2.properties.bind;\r\n  }\r\n  return !vnode1.properties && !vnode2.properties;\r\n};\r\n\r\nlet toTextVNode = (data: any): VNode => {\r\n  return {\r\n    vnodeSelector: '',\r\n    properties: undefined,\r\n    children: undefined,\r\n    text: data.toString(),\r\n    domNode: null\r\n  };\r\n};\r\n\r\nlet appendChildren = function(parentSelector: string, insertions: any[], main: VNode[]) {\r\n  for (let i = 0; i < insertions.length; i++) {\r\n    let item = insertions[i];\r\n    if (Array.isArray(item)) {\r\n      appendChildren(parentSelector, item, main);\r\n    } else {\r\n      if (item !== null && item !== undefined) {\r\n        if (!item.hasOwnProperty('vnodeSelector')) {\r\n          item = toTextVNode(item);\r\n        }\r\n        main.push(item);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Render helper functions\r\n\r\nlet missingTransition = function() {\r\n  throw new Error('Provide a transitions object to the projectionOptions to do animations');\r\n};\r\n\r\nconst DEFAULT_PROJECTION_OPTIONS: ProjectionOptions = {\r\n  namespace: undefined,\r\n  eventHandlerInterceptor: undefined,\r\n  styleApplyer: function(domNode: HTMLElement, styleName: string, value: string) {\r\n    // Provides a hook to add vendor prefixes for browsers that still need it.\r\n    (domNode.style as any)[styleName] = value;\r\n  },\r\n  transitions: {\r\n    enter: missingTransition,\r\n    exit: missingTransition\r\n  }\r\n};\r\n\r\nlet applyDefaultProjectionOptions = function(projectionOptions: ProjectionOptions) {\r\n  return extend(DEFAULT_PROJECTION_OPTIONS, projectionOptions);\r\n};\r\n\r\nlet checkStyleValue = (styleValue: Object) => {\r\n  if (typeof styleValue !== 'string') {\r\n    throw new Error('Style values must be strings');\r\n  }\r\n};\r\n\r\nlet setProperties = function(domNode: Node, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\r\n  if (!properties) {\r\n    return;\r\n  }\r\n  let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n  let propNames = Object.keys(properties);\r\n  let propCount = propNames.length;\r\n  for (let i = 0; i < propCount; i++) {\r\n    let propName = propNames[i];\r\n    /* tslint:disable:no-var-keyword: edge case */\r\n    var propValue = properties[propName];\r\n    /* tslint:enable:no-var-keyword */\r\n    if (propName === 'className') {\r\n      throw new Error('Property \"className\" is not supported, use \"class\".');\r\n    } else if (propName === 'class') {\r\n      if ((domNode as Element).className) {\r\n        // May happen if classes is specified before class\r\n        (domNode as Element).className += ' ' + propValue;\r\n      } else {\r\n        (domNode as Element).className = propValue;\r\n      }\r\n    } else if (propName === 'classes') {\r\n      // object with string keys and boolean values\r\n      let classNames = Object.keys(propValue);\r\n      let classNameCount = classNames.length;\r\n      for (let j = 0; j < classNameCount; j++) {\r\n        let className = classNames[j];\r\n        if (propValue[className]) {\r\n          (domNode as Element).classList.add(className);\r\n        }\r\n      }\r\n    } else if (propName === 'styles') {\r\n      // object with string keys and string (!) values\r\n      let styleNames = Object.keys(propValue);\r\n      let styleCount = styleNames.length;\r\n      for (let j = 0; j < styleCount; j++) {\r\n        let styleName = styleNames[j];\r\n        let styleValue = propValue[styleName];\r\n        if (styleValue) {\r\n          checkStyleValue(styleValue);\r\n          projectionOptions.styleApplyer(<HTMLElement>domNode, styleName, styleValue);\r\n        }\r\n      }\r\n    } else if (propName === 'key') {\r\n      continue;\r\n    } else if (propValue === null || propValue === undefined) {\r\n      continue;\r\n    } else {\r\n      let type = typeof propValue;\r\n      if (type === 'function') {\r\n        if (eventHandlerInterceptor && (propName.lastIndexOf('on', 0) === 0)) { // lastIndexOf(,0)===0 -> startsWith\r\n          propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\r\n          if (propName === 'oninput') {\r\n            (function() {\r\n              // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\r\n              let oldPropValue = propValue;\r\n              propValue = function(evt: Event) {\r\n                (evt.target as any)['oninput-value'] = (evt.target as HTMLInputElement).value; // may be HTMLTextAreaElement as well\r\n                oldPropValue.apply(this, [evt]);\r\n              };\r\n            } ());\r\n          }\r\n          (domNode as any)[propName] = propValue;\r\n        }\r\n      } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\r\n        (domNode as Element).setAttribute(propName, propValue);\r\n      } else {\r\n        (domNode as any)[propName] = propValue;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet updateProperties = function(domNode: Node, previousProperties: VNodeProperties, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\r\n  if (!properties) {\r\n    return;\r\n  }\r\n  let propertiesUpdated = false;\r\n  let propNames = Object.keys(properties);\r\n  let propCount = propNames.length;\r\n  for (let i = 0; i < propCount; i++) {\r\n    let propName = propNames[i];\r\n    // assuming that properties will be nullified instead of missing is by design\r\n    let propValue = properties[propName];\r\n    let previousValue = previousProperties[propName];\r\n    if (propName === 'class') {\r\n      if (previousValue !== propValue) {\r\n        throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\r\n      }\r\n    } else if (propName === 'classes') {\r\n      let classList = (domNode as Element).classList;\r\n      let classNames = Object.keys(propValue);\r\n      let classNameCount = classNames.length;\r\n      for (let j = 0; j < classNameCount; j++) {\r\n        let className = classNames[j];\r\n        let on = !!propValue[className];\r\n        let previousOn = !!previousValue[className];\r\n        if (on === previousOn) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if (on) {\r\n          classList.add(className);\r\n        } else {\r\n          classList.remove(className);\r\n        }\r\n      }\r\n    } else if (propName === 'styles') {\r\n      let styleNames = Object.keys(propValue);\r\n      let styleCount = styleNames.length;\r\n      for (let j = 0; j < styleCount; j++) {\r\n        let styleName = styleNames[j];\r\n        let newStyleValue = propValue[styleName];\r\n        let oldStyleValue = previousValue[styleName];\r\n        if (newStyleValue === oldStyleValue) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if (newStyleValue) {\r\n          checkStyleValue(newStyleValue);\r\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, newStyleValue);\r\n        } else {\r\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, '');\r\n        }\r\n      }\r\n    } else {\r\n      if (!propValue && typeof previousValue === 'string') {\r\n        propValue = '';\r\n      }\r\n      if (propName === 'value') { // value can be manipulated by the user directly and using event.preventDefault() is not an option\r\n        if ((domNode as any)[propName] !== propValue && (domNode as any)['oninput-value'] !== propValue) {\r\n          (domNode as any)[propName] = propValue; // Reset the value, even if the virtual DOM did not change\r\n          (domNode as any)['oninput-value'] = undefined;\r\n        } // else do not update the domNode, otherwise the cursor position would be changed\r\n        if (propValue !== previousValue) {\r\n          propertiesUpdated = true;\r\n        }\r\n      } else if (propValue !== previousValue) {\r\n        let type = typeof propValue;\r\n        if (type === 'function') {\r\n          throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\r\n            '). Hint: declare event handler functions outside the render() function.');\r\n        }\r\n        if (type === 'string' && propName !== 'innerHTML') {\r\n          (domNode as Element).setAttribute(propName, propValue);\r\n        } else {\r\n          if ((domNode as any)[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\r\n            (domNode as any)[propName] = propValue;\r\n          }\r\n        }\r\n        propertiesUpdated = true;\r\n      }\r\n    }\r\n  }\r\n  return propertiesUpdated;\r\n};\r\n\r\nlet findIndexOfChild = function(children: VNode[], sameAs: VNode, start: number) {\r\n  if (sameAs.vnodeSelector !== '') {\r\n    // Never scan for text-nodes\r\n    for (let i = start; i < children.length; i++) {\r\n      if (same(children[i], sameAs)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nlet nodeAdded = function(vNode: VNode, transitions: TransitionStrategy) {\r\n  if (vNode.properties) {\r\n    let enterAnimation = vNode.properties.enterAnimation;\r\n    if (enterAnimation) {\r\n      if (typeof enterAnimation === 'function') {\r\n        enterAnimation(vNode.domNode as Element, vNode.properties);\r\n      } else {\r\n        transitions.enter(vNode.domNode as Element, vNode.properties, enterAnimation as string);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet nodeToRemove = function(vNode: VNode, transitions: TransitionStrategy) {\r\n  let domNode = vNode.domNode;\r\n  if (vNode.properties) {\r\n    let exitAnimation = vNode.properties.exitAnimation;\r\n    if (exitAnimation) {\r\n      (domNode as HTMLElement).style.pointerEvents = 'none';\r\n      let removeDomNode = function() {\r\n        if (domNode.parentNode) {\r\n          domNode.parentNode.removeChild(domNode);\r\n        }\r\n      };\r\n      if (typeof exitAnimation === 'function') {\r\n        exitAnimation(domNode as Element, removeDomNode, vNode.properties);\r\n        return;\r\n      } else {\r\n        transitions.exit(vNode.domNode as Element, vNode.properties, exitAnimation as string, removeDomNode);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (domNode.parentNode) {\r\n    domNode.parentNode.removeChild(domNode);\r\n  }\r\n};\r\n\r\nlet checkDistinguishable = function(childNodes: VNode[], indexToCheck: number, parentVNode: VNode, operation: string) {\r\n  let childNode = childNodes[indexToCheck];\r\n  if (childNode.vnodeSelector === '') {\r\n    return; // Text nodes need not be distinguishable\r\n  }\r\n  let key = childNode.properties ? (childNode.properties.key || childNode.properties.bind) : undefined;\r\n  if (!key) { // A key is just assumed to be unique\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n      if (i !== indexToCheck) {\r\n        let node = childNodes[i];\r\n        if (same(node, childNode)) {\r\n          if (operation === 'added') {\r\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\r\n              'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\r\n          } else {\r\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\r\n              'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet createDom: (vnode: VNode, parentNode: Node, insertBefore: Node, projectionOptions: ProjectionOptions) => void;\r\nlet updateDom: (previous: VNode, vnode: VNode, projectionOptions: ProjectionOptions) => boolean;\r\n\r\nlet updateChildren = function(vnode: VNode, domNode: Node, oldChildren: VNode[], newChildren: VNode[], projectionOptions: ProjectionOptions) {\r\n  if (oldChildren === newChildren) {\r\n    return false;\r\n  }\r\n  oldChildren = oldChildren || emptyArray;\r\n  newChildren = newChildren || emptyArray;\r\n  let oldChildrenLength = oldChildren.length;\r\n  let newChildrenLength = newChildren.length;\r\n  let transitions = projectionOptions.transitions;\r\n\r\n  let oldIndex = 0;\r\n  let newIndex = 0;\r\n  let i: number;\r\n  let textUpdated = false;\r\n  while (newIndex < newChildrenLength) {\r\n    let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\r\n    let newChild = newChildren[newIndex];\r\n    if (oldChild !== undefined && same(oldChild, newChild)) {\r\n      textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\r\n      oldIndex++;\r\n    } else {\r\n      let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\r\n      if (findOldIndex >= 0) {\r\n        // Remove preceding missing children\r\n        for (i = oldIndex; i < findOldIndex; i++) {\r\n          nodeToRemove(oldChildren[i], transitions);\r\n          checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n        }\r\n        textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\r\n        oldIndex = findOldIndex + 1;\r\n      } else {\r\n        // New child\r\n        createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\r\n        nodeAdded(newChild, transitions);\r\n        checkDistinguishable(newChildren, newIndex, vnode, 'added');\r\n      }\r\n    }\r\n    newIndex++;\r\n  }\r\n  if (oldChildrenLength > oldIndex) {\r\n    // Remove child fragments\r\n    for (i = oldIndex; i < oldChildrenLength; i++) {\r\n      nodeToRemove(oldChildren[i], transitions);\r\n      checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n    }\r\n  }\r\n  return textUpdated;\r\n};\r\n\r\nlet addChildren = function(domNode: Node, children: VNode[], projectionOptions: ProjectionOptions) {\r\n  if (!children) {\r\n    return;\r\n  }\r\n  for (let i = 0; i < children.length; i++) {\r\n    createDom(children[i], domNode, undefined, projectionOptions);\r\n  }\r\n};\r\n\r\nlet initPropertiesAndChildren = function(domNode: Node, vnode: VNode, projectionOptions: ProjectionOptions) {\r\n  addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\r\n  if (vnode.text) {\r\n    domNode.textContent = vnode.text;\r\n  }\r\n  setProperties(domNode, vnode.properties, projectionOptions);\r\n  if (vnode.properties && vnode.properties.afterCreate) {\r\n    vnode.properties.afterCreate(domNode as Element, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n  }\r\n};\r\n\r\ncreateDom = function(vnode, parentNode, insertBefore, projectionOptions) {\r\n  let domNode: Node, i: number, c: string, start = 0, type: string, found: string;\r\n  let vnodeSelector = vnode.vnodeSelector;\r\n  if (vnodeSelector === '') {\r\n    domNode = vnode.domNode = document.createTextNode(vnode.text);\r\n    if (insertBefore !== undefined) {\r\n      parentNode.insertBefore(domNode, insertBefore);\r\n    } else {\r\n      parentNode.appendChild(domNode);\r\n    }\r\n  } else {\r\n    for (i = 0; i <= vnodeSelector.length; ++i) {\r\n      c = vnodeSelector.charAt(i);\r\n      if (i === vnodeSelector.length || c === '.' || c === '#') {\r\n        type = vnodeSelector.charAt(start - 1);\r\n        found = vnodeSelector.slice(start, i);\r\n        if (type === '.') {\r\n          (domNode as HTMLElement).classList.add(found);\r\n        } else if (type === '#') {\r\n          (domNode as Element).id = found;\r\n        } else {\r\n          if (found === 'svg') {\r\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n          }\r\n          if (projectionOptions.namespace !== undefined) {\r\n            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\r\n          } else {\r\n            domNode = vnode.domNode = document.createElement(found);\r\n          }\r\n          if (insertBefore !== undefined) {\r\n            parentNode.insertBefore(domNode, insertBefore);\r\n          } else {\r\n            parentNode.appendChild(domNode);\r\n          }\r\n        }\r\n        start = i + 1;\r\n      }\r\n    }\r\n    initPropertiesAndChildren(domNode, vnode, projectionOptions);\r\n  }\r\n};\r\n\r\nupdateDom = function(previous, vnode, projectionOptions) {\r\n  let domNode = previous.domNode;\r\n  let textUpdated = false;\r\n  if (previous === vnode) {\r\n    return textUpdated; // By contract, VNode objects may not be modified after passing them to maquette\r\n  }\r\n  let updated = false;\r\n  if (vnode.vnodeSelector === '') {\r\n    if (vnode.text !== previous.text) {\r\n      let newVNode = document.createTextNode(vnode.text);\r\n      domNode.parentNode.replaceChild(newVNode, domNode);\r\n      vnode.domNode = newVNode;\r\n      textUpdated = true;\r\n      return textUpdated;\r\n    }\r\n  } else {\r\n    if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\r\n      projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n    }\r\n    if (previous.text !== vnode.text) {\r\n      updated = true;\r\n      if (vnode.text === undefined) {\r\n        domNode.removeChild(domNode.firstChild); // the only textnode presumably\r\n      } else {\r\n        domNode.textContent = vnode.text;\r\n      }\r\n    }\r\n    updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\r\n    updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\r\n    if (vnode.properties && vnode.properties.afterUpdate) {\r\n      vnode.properties.afterUpdate(<Element>domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n    }\r\n  }\r\n  if (updated && vnode.properties && vnode.properties.updateAnimation) {\r\n    vnode.properties.updateAnimation(<Element>domNode, vnode.properties, previous.properties);\r\n  }\r\n  vnode.domNode = previous.domNode;\r\n  return textUpdated;\r\n};\r\n\r\nlet createProjection = function(vnode: VNode, projectionOptions: ProjectionOptions): Projection {\r\n  return {\r\n    update: function(updatedVnode: VNode) {\r\n      if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\r\n        throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\r\n      }\r\n      updateDom(vnode, updatedVnode, projectionOptions);\r\n      vnode = updatedVnode;\r\n    },\r\n    domNode: <Element>vnode.domNode\r\n  };\r\n};\r\n\r\n// The following line is not possible in Typescript, hence the workaround in the two lines below\r\n// export type VNodeChild = string|VNode|Array<VNodeChild>\r\n/**\r\n * Only needed for the defintion of [[VNodeChild]].\r\n */\r\nexport interface VNodeChildren extends Array<VNodeChild> { };\r\n/**\r\n * These are valid values for the children parameter of the [[h]] function.\r\n */\r\nexport type VNodeChild = string | VNode | VNodeChildren;\r\n\r\n/**\r\n * Contains all valid method signatures for the [[h]] function.\r\n */\r\nexport interface H {\r\n  /**\r\n   * @param selector    Contains the tagName, id and fixed css classnames in CSS selector format.\r\n   *                    It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\r\n   * @param properties  An object literal containing properties that will be placed on the DOM node.\r\n   * @param children    Virtual DOM nodes and strings to add as child nodes.\r\n   *                    `children` may contain [[VNode]]s, `string`s, nested arrays, `null` and `undefined`.\r\n   *                    Nested arrays are flattened, `null` and `undefined` are removed.\r\n   *\r\n   * @returns           A VNode object, used to render a real DOM later.\r\n   */\r\n  (selector: string, properties?: VNodeProperties, ...children: VNodeChild[]): VNode;\r\n  (selector: string, ...children: VNodeChild[]): VNode;\r\n}\r\n\r\n/**\r\n * The `h` function is used to create a virtual DOM node.\r\n * This function is largely inspired by the mercuryjs and mithril frameworks.\r\n * The `h` stands for (virtual) hyperscript.\r\n *\r\n * All possible method signatures of this function can be found in the [[H]] 'interface'.\r\n *\r\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\r\n */\r\nexport let h: H;\r\n\r\n// The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\r\nh = function(selector: string): VNode {\r\n  let properties = arguments[1];\r\n  if (typeof selector !== 'string') {\r\n    throw new Error();\r\n  }\r\n  let childIndex = 1;\r\n  if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\r\n    childIndex = 2;\r\n  } else {\r\n    // Optional properties argument was omitted\r\n    properties = undefined;\r\n  }\r\n  let text = undefined as string;\r\n  let children = undefined as VNode[];\r\n  let argsLength = arguments.length;\r\n  // Recognize a common special case where there is only a single text node\r\n  if (argsLength === childIndex + 1) {\r\n    let onlyChild = arguments[childIndex];\r\n    if (typeof onlyChild === 'string') {\r\n      text = onlyChild;\r\n    } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\r\n      text = onlyChild[0];\r\n    }\r\n  }\r\n  if (text === undefined) {\r\n    children = [];\r\n    for (; childIndex < arguments.length; childIndex++) {\r\n      let child = arguments[childIndex];\r\n      if (child === null || child === undefined) {\r\n        continue;\r\n      } else if (Array.isArray(child)) {\r\n        appendChildren(selector, child, children);\r\n      } else if (child.hasOwnProperty('vnodeSelector')) {\r\n        children.push(child);\r\n      } else {\r\n        children.push(toTextVNode(child));\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    vnodeSelector: selector,\r\n    properties: properties,\r\n    children: children,\r\n    text: text,\r\n    domNode: null\r\n  };\r\n};\r\n\r\n/**\r\n * Contains simple low-level utility functions to manipulate the real DOM.\r\n */\r\nexport let dom = {\r\n\r\n  /**\r\n   * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\r\n   * its [[Projection.domNode|domNode]] property.\r\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n   * objects may only be rendered once.\r\n   * @param projectionOptions - Options to be used to create and update the projection.\r\n   * @returns The [[Projection]] which also contains the DOM Node that was created.\r\n   */\r\n  create: function(vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, document.createElement('div'), undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Appends a new childnode to the DOM which is generated from a [[VNode]].\r\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n   * @param parentNode - The parent node for the new childNode.\r\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n   * objects may only be rendered once.\r\n   * @param projectionOptions - Options to be used to create and update the [[Projection]].\r\n   * @returns The [[Projection]] that was created.\r\n   */\r\n  append: function(parentNode: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, parentNode, undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Inserts a new DOM node which is generated from a [[VNode]].\r\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n   * @param beforeNode - The node that the DOM Node is inserted before.\r\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\r\n   * NOTE: [[VNode]] objects may only be rendered once.\r\n   * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n   * @returns The [[Projection]] that was created.\r\n   */\r\n  insertBefore: function(beforeNode: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\r\n   * This means that the virtual DOM and the real DOM will have one overlapping element.\r\n   * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\r\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n   * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\r\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\r\n   * may only be rendered once.\r\n   * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n   * @returns The [[Projection]] that was created.\r\n   */\r\n  merge: function(element: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    vnode.domNode = element;\r\n    initPropertiesAndChildren(element, vnode, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs.\r\n * On subsequent calls the previous outcome is returned if the inputs are identical.\r\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\r\n * Instances of CalculationCache can be created using [[createCache]].\r\n *\r\n * @param <Result> The type of the value that is cached.\r\n */\r\nexport interface CalculationCache<Result> {\r\n  /**\r\n   * Manually invalidates the cached outcome.\r\n   */\r\n  invalidate(): void;\r\n  /**\r\n   * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\r\n   * Otherwise, the calculation function is invoked and its result is cached and returned.\r\n   * Objects in the inputs array are compared using ===.\r\n   * @param inputs - Array of objects that are to be compared using === with the inputs from the previous invocation.\r\n   * These objects are assumed to be immutable primitive values.\r\n   * @param calculation - Function that takes zero arguments and returns an object (A [[VNode]] assumably) that can be cached.\r\n   */\r\n  result(inputs: Object[], calculation: () => Result): Result;\r\n}\r\n\r\n/**\r\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\r\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\r\n * For more information, see [[CalculationCache]].\r\n *\r\n * @param <Result> The type of the value that is cached.\r\n */\r\nexport let createCache = <Result>(): CalculationCache<Result> => {\r\n  let cachedInputs = undefined as Object[];\r\n  let cachedOutcome = undefined as Result;\r\n  let result = {\r\n\r\n    invalidate: function() {\r\n      cachedOutcome = undefined;\r\n      cachedInputs = undefined;\r\n    },\r\n\r\n    result: function(inputs: Object[], calculation: () => Result) {\r\n      if (cachedInputs) {\r\n        for (let i = 0; i < inputs.length; i++) {\r\n          if (cachedInputs[i] !== inputs[i]) {\r\n            cachedOutcome = undefined;\r\n          }\r\n        }\r\n      }\r\n      if (!cachedOutcome) {\r\n        cachedOutcome = calculation();\r\n        cachedInputs = inputs;\r\n      }\r\n      return cachedOutcome;\r\n    }\r\n  };\r\n  return result;\r\n};\r\n\r\n/**\r\n * Keeps an array of result objects synchronized with an array of source objects.\r\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\r\n *\r\n * Mapping provides a [[map]] function that updates its [[results]].\r\n * The [[map]] function can be called multiple times and the results will get created, removed and updated accordingly.\r\n * A Mapping can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\r\n * Instances of Mapping can be created using [[createMapping]].\r\n *\r\n * @param <Source>   The type of source elements. Usually the data type.\r\n * @param <Target>   The type of target elements. Usually the component type.\r\n */\r\nexport interface Mapping<Source, Target> {\r\n  /**\r\n   * The array of results. These results will be synchronized with the latest array of sources that were provided using [[map]].\r\n   */\r\n  results: Array<Target>;\r\n  /**\r\n   * Maps a new array of sources and updates [[results]].\r\n   *\r\n   * @param newSources   The new array of sources.\r\n   */\r\n  map(newSources: Array<Source>): void;\r\n}\r\n\r\n/**\r\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\r\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\r\n *\r\n * @param <Source>       The type of source items. A database-record for instance.\r\n * @param <Target>       The type of target items. A [[Component]] for instance.\r\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\r\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\r\n *                       to the `callback` argument in `Array.map(callback)`.\r\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\r\n */\r\nexport let createMapping = <Source, Target>(\r\n  getSourceKey: (source: Source) => (string | number),\r\n  createResult: (source: Source, index: number) => Target,\r\n  updateResult: (source: Source, target: Target, index: number) => void): Mapping<Source, Target> => {\r\n  let keys = [] as Object[];\r\n  let results = [] as Target[];\r\n\r\n  return {\r\n    results: results,\r\n    map: function(newSources: Source[]) {\r\n      let newKeys = newSources.map(getSourceKey);\r\n      let oldTargets = results.slice();\r\n      let oldIndex = 0;\r\n      for (let i = 0; i < newSources.length; i++) {\r\n        let source = newSources[i];\r\n        let sourceKey = newKeys[i];\r\n        if (sourceKey === keys[oldIndex]) {\r\n          results[i] = oldTargets[oldIndex];\r\n          updateResult(source, oldTargets[oldIndex], i);\r\n          oldIndex++;\r\n        } else {\r\n          let found = false;\r\n          for (let j = 1; j < keys.length; j++) {\r\n            let searchIndex = (oldIndex + j) % keys.length;\r\n            if (keys[searchIndex] === sourceKey) {\r\n              results[i] = oldTargets[searchIndex];\r\n              updateResult(newSources[i], oldTargets[searchIndex], i);\r\n              oldIndex = searchIndex + 1;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            results[i] = createResult(source, i);\r\n          }\r\n        }\r\n      }\r\n      results.length = newSources.length;\r\n      keys = newKeys;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a [[Projector]] instance using the provided projectionOptions.\r\n *\r\n * For more information, see [[Projector]].\r\n *\r\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\r\n */\r\nexport let createProjector = function(projectionOptions: ProjectionOptions): Projector {\r\n  let projector: Projector;\r\n  projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n  let originalEventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n  projectionOptions.eventHandlerInterceptor = function(propertyName: string, eventHandler: Function, domNode: Node, properties: VNodeProperties) {\r\n    let scheduleRenderAndInvokeEventHandler = function() {\r\n      // intercept function calls (event handlers) to do a render afterwards.\r\n      projector.scheduleRender();\r\n      return eventHandler.apply(properties.bind || this, arguments);\r\n    };\r\n    if (originalEventHandlerInterceptor) {\r\n      return originalEventHandlerInterceptor(propertyName, scheduleRenderAndInvokeEventHandler, domNode, properties);\r\n    } else {\r\n      return scheduleRenderAndInvokeEventHandler;\r\n    }\r\n  };\r\n  let renderCompleted = true;\r\n  let scheduled: number;\r\n  let stopped = false;\r\n  let projections = [] as Projection[];\r\n  let renderFunctions = [] as (() => VNode)[]; // matches the projections array\r\n\r\n  let doRender = function() {\r\n    scheduled = undefined;\r\n    if (!renderCompleted) {\r\n      return; // The last render threw an error, it should be logged in the browser console.\r\n    }\r\n    renderCompleted = false;\r\n    for (let i = 0; i < projections.length; i++) {\r\n      let updatedVnode = renderFunctions[i]();\r\n      projections[i].update(updatedVnode);\r\n    }\r\n    renderCompleted = true;\r\n  };\r\n\r\n  projector = {\r\n    scheduleRender: function() {\r\n      if (!scheduled && !stopped) {\r\n        scheduled = requestAnimationFrame(doRender);\r\n      }\r\n    },\r\n    stop: function() {\r\n      if (scheduled) {\r\n        cancelAnimationFrame(scheduled);\r\n        scheduled = undefined;\r\n      }\r\n      stopped = true;\r\n    },\r\n\r\n    resume: function() {\r\n      stopped = false;\r\n      renderCompleted = true;\r\n      projector.scheduleRender();\r\n    },\r\n\r\n    append: function(parentNode, renderMaquetteFunction) {\r\n      projections.push(dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n\r\n    insertBefore: function(beforeNode, renderMaquetteFunction) {\r\n      projections.push(dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n\r\n    merge: function(domNode, renderMaquetteFunction) {\r\n      projections.push(dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n\r\n    replace: function(domNode, renderMaquetteFunction) {\r\n      let vnode = renderMaquetteFunction();\r\n      createDom(vnode, domNode.parentNode, domNode, projectionOptions);\r\n      domNode.parentNode.removeChild(domNode);\r\n      projections.push(createProjection(vnode, projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    }\r\n  };\r\n  return projector;\r\n};\r\n\r\n/**\r\n * A component is a pattern with which you can split up your web application into self-contained parts.\r\n *\r\n * A component may contain other components.\r\n * This can be achieved by calling the subcomponents `renderMaquette` functions during the [[renderMaquette]] function and by using the\r\n * resulting [[VNode]]s in the return value.\r\n *\r\n * This interface is not used anywhere in the maquette sourcecode, but this is a widely used pattern.\r\n */\r\nexport interface Component {\r\n  /**\r\n   * A function that returns the DOM representation of the component.\r\n   */\r\n  renderMaquette(): VNode;\r\n}\r\n"],"sourceRoot":"/source/"}