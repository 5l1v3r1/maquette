{"version":3,"sources":["maquette.js","../../../src/maquette.ts"],"names":["root","factory","define","amd","exports","nodeName","maquette","this","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","extend","base","overrides","result","Object","keys","forEach","key","same","vnode1","vnode2","vnodeSelector","properties","bind","toTextVNode","data","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length_1","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","split","token","classList","add","classNames","classNameCount","j","className","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","target","apply","setAttributeNS","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","c","found","document","createTextNode","appendChild","charAt","slice","id","createElementNS","createElement","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","append","beforeNode","merge","element","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","replace","detach","splice"],"mappings":"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","file":"maquette.min.js","sourcesContent":["// Comment that is displayed in the API documentation for the maquette module:\n/**\n * Welcome to the API documentation of the **maquette** library.\n *\n * [[http://maquettejs.org/|To the maquette homepage]]\n */\n;\n;\n;\n;\nvar NAMESPACE_W3 = 'http://www.w3.org/';\nvar NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\nvar NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n// Utilities\nvar emptyArray = [];\nvar extend = function (base, overrides) {\n    var result = {};\n    Object.keys(base).forEach(function (key) {\n        result[key] = base[key];\n    });\n    if (overrides) {\n        Object.keys(overrides).forEach(function (key) {\n            result[key] = overrides[key];\n        });\n    }\n    return result;\n};\n// Hyperscript helper functions\nvar same = function (vnode1, vnode2) {\n    if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n        return false;\n    }\n    if (vnode1.properties && vnode2.properties) {\n        if (vnode1.properties.key !== vnode2.properties.key) {\n            return false;\n        }\n        return vnode1.properties.bind === vnode2.properties.bind;\n    }\n    return !vnode1.properties && !vnode2.properties;\n};\nvar toTextVNode = function (data) {\n    return {\n        vnodeSelector: '',\n        properties: undefined,\n        children: undefined,\n        text: data.toString(),\n        domNode: null\n    };\n};\nvar appendChildren = function (parentSelector, insertions, main) {\n    for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n        var item = insertions[i];\n        if (Array.isArray(item)) {\n            appendChildren(parentSelector, item, main);\n        }\n        else {\n            if (item !== null && item !== undefined) {\n                if (!item.hasOwnProperty('vnodeSelector')) {\n                    item = toTextVNode(item);\n                }\n                main.push(item);\n            }\n        }\n    }\n};\n// Render helper functions\nvar missingTransition = function () {\n    throw new Error('Provide a transitions object to the projectionOptions to do animations');\n};\nvar DEFAULT_PROJECTION_OPTIONS = {\n    namespace: undefined,\n    eventHandlerInterceptor: undefined,\n    styleApplyer: function (domNode, styleName, value) {\n        // Provides a hook to add vendor prefixes for browsers that still need it.\n        domNode.style[styleName] = value;\n    },\n    transitions: {\n        enter: missingTransition,\n        exit: missingTransition\n    }\n};\nvar applyDefaultProjectionOptions = function (projectorOptions) {\n    return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n};\nvar checkStyleValue = function (styleValue) {\n    if (typeof styleValue !== 'string') {\n        throw new Error('Style values must be strings');\n    }\n};\nvar setProperties = function (domNode, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    for (var i = 0; i < propCount; i++) {\n        var propName = propNames[i];\n        /* tslint:disable:no-var-keyword: edge case */\n        var propValue = properties[propName];\n        /* tslint:enable:no-var-keyword */\n        if (propName === 'className') {\n            throw new Error('Property \"className\" is not supported, use \"class\".');\n        }\n        else if (propName === 'class') {\n            propValue.split(/\\s+/).forEach(function (token) { return domNode.classList.add(token); });\n        }\n        else if (propName === 'classes') {\n            // object with string keys and boolean values\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                if (propValue[className]) {\n                    domNode.classList.add(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            // object with string keys and string (!) values\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var styleValue = propValue[styleName];\n                if (styleValue) {\n                    checkStyleValue(styleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                }\n            }\n        }\n        else if (propName === 'key') {\n            continue;\n        }\n        else if (propValue === null || propValue === undefined) {\n            continue;\n        }\n        else {\n            var type = typeof propValue;\n            if (type === 'function') {\n                if (propName.lastIndexOf('on', 0) === 0) {\n                    if (eventHandlerInterceptor) {\n                        propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n                    }\n                    if (propName === 'oninput') {\n                        (function () {\n                            // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                            var oldPropValue = propValue;\n                            propValue = function (evt) {\n                                evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well\n                                oldPropValue.apply(this, [evt]);\n                            };\n                        }());\n                    }\n                    domNode[propName] = propValue;\n                }\n            }\n            else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                    domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                }\n                else {\n                    domNode.setAttribute(propName, propValue);\n                }\n            }\n            else {\n                domNode[propName] = propValue;\n            }\n        }\n    }\n};\nvar updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var propertiesUpdated = false;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    for (var i = 0; i < propCount; i++) {\n        var propName = propNames[i];\n        // assuming that properties will be nullified instead of missing is by design\n        var propValue = properties[propName];\n        var previousValue = previousProperties[propName];\n        if (propName === 'class') {\n            if (previousValue !== propValue) {\n                throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n            }\n        }\n        else if (propName === 'classes') {\n            var classList = domNode.classList;\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                var on = !!propValue[className];\n                var previousOn = !!previousValue[className];\n                if (on === previousOn) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (on) {\n                    classList.add(className);\n                }\n                else {\n                    classList.remove(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var newStyleValue = propValue[styleName];\n                var oldStyleValue = previousValue[styleName];\n                if (newStyleValue === oldStyleValue) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (newStyleValue) {\n                    checkStyleValue(newStyleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                }\n                else {\n                    projectionOptions.styleApplyer(domNode, styleName, '');\n                }\n            }\n        }\n        else {\n            if (!propValue && typeof previousValue === 'string') {\n                propValue = '';\n            }\n            if (propName === 'value') {\n                if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                    domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n                    domNode['oninput-value'] = undefined;\n                } // else do not update the domNode, otherwise the cursor position would be changed\n                if (propValue !== previousValue) {\n                    propertiesUpdated = true;\n                }\n            }\n            else if (propValue !== previousValue) {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\n                        '). Hint: declare event handler functions outside the render() function.');\n                }\n                if (type === 'string' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    }\n                    else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                }\n                else {\n                    if (domNode[propName] !== propValue) {\n                        domNode[propName] = propValue;\n                    }\n                }\n                propertiesUpdated = true;\n            }\n        }\n    }\n    return propertiesUpdated;\n};\nvar findIndexOfChild = function (children, sameAs, start) {\n    if (sameAs.vnodeSelector !== '') {\n        // Never scan for text-nodes\n        for (var i = start; i < children.length; i++) {\n            if (same(children[i], sameAs)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\nvar nodeAdded = function (vNode, transitions) {\n    if (vNode.properties) {\n        var enterAnimation = vNode.properties.enterAnimation;\n        if (enterAnimation) {\n            if (typeof enterAnimation === 'function') {\n                enterAnimation(vNode.domNode, vNode.properties);\n            }\n            else {\n                transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n            }\n        }\n    }\n};\nvar nodeToRemove = function (vNode, transitions) {\n    var domNode = vNode.domNode;\n    if (vNode.properties) {\n        var exitAnimation = vNode.properties.exitAnimation;\n        if (exitAnimation) {\n            domNode.style.pointerEvents = 'none';\n            var removeDomNode = function () {\n                if (domNode.parentNode) {\n                    domNode.parentNode.removeChild(domNode);\n                }\n            };\n            if (typeof exitAnimation === 'function') {\n                exitAnimation(domNode, removeDomNode, vNode.properties);\n                return;\n            }\n            else {\n                transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                return;\n            }\n        }\n    }\n    if (domNode.parentNode) {\n        domNode.parentNode.removeChild(domNode);\n    }\n};\nvar checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n    var childNode = childNodes[indexToCheck];\n    if (childNode.vnodeSelector === '') {\n        return; // Text nodes need not be distinguishable\n    }\n    var properties = childNode.properties;\n    var key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;\n    if (!key) {\n        for (var i = 0; i < childNodes.length; i++) {\n            if (i !== indexToCheck) {\n                var node = childNodes[i];\n                if (same(node, childNode)) {\n                    if (operation === 'added') {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                    else {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                }\n            }\n        }\n    }\n};\nvar createDom;\nvar updateDom;\nvar updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n    if (oldChildren === newChildren) {\n        return false;\n    }\n    oldChildren = oldChildren || emptyArray;\n    newChildren = newChildren || emptyArray;\n    var oldChildrenLength = oldChildren.length;\n    var newChildrenLength = newChildren.length;\n    var transitions = projectionOptions.transitions;\n    var oldIndex = 0;\n    var newIndex = 0;\n    var i;\n    var textUpdated = false;\n    while (newIndex < newChildrenLength) {\n        var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\n        var newChild = newChildren[newIndex];\n        if (oldChild !== undefined && same(oldChild, newChild)) {\n            textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n            oldIndex++;\n        }\n        else {\n            var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n            if (findOldIndex >= 0) {\n                // Remove preceding missing children\n                for (i = oldIndex; i < findOldIndex; i++) {\n                    nodeToRemove(oldChildren[i], transitions);\n                    checkDistinguishable(oldChildren, i, vnode, 'removed');\n                }\n                textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                oldIndex = findOldIndex + 1;\n            }\n            else {\n                // New child\n                createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                nodeAdded(newChild, transitions);\n                checkDistinguishable(newChildren, newIndex, vnode, 'added');\n            }\n        }\n        newIndex++;\n    }\n    if (oldChildrenLength > oldIndex) {\n        // Remove child fragments\n        for (i = oldIndex; i < oldChildrenLength; i++) {\n            nodeToRemove(oldChildren[i], transitions);\n            checkDistinguishable(oldChildren, i, vnode, 'removed');\n        }\n    }\n    return textUpdated;\n};\nvar addChildren = function (domNode, children, projectionOptions) {\n    if (!children) {\n        return;\n    }\n    for (var i = 0; i < children.length; i++) {\n        createDom(children[i], domNode, undefined, projectionOptions);\n    }\n};\nvar initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n    addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n    if (vnode.text) {\n        domNode.textContent = vnode.text;\n    }\n    setProperties(domNode, vnode.properties, projectionOptions);\n    if (vnode.properties && vnode.properties.afterCreate) {\n        vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n    }\n};\ncreateDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n    var domNode, i, c, start = 0, type, found;\n    var vnodeSelector = vnode.vnodeSelector;\n    if (vnodeSelector === '') {\n        domNode = vnode.domNode = document.createTextNode(vnode.text);\n        if (insertBefore !== undefined) {\n            parentNode.insertBefore(domNode, insertBefore);\n        }\n        else {\n            parentNode.appendChild(domNode);\n        }\n    }\n    else {\n        for (i = 0; i <= vnodeSelector.length; ++i) {\n            c = vnodeSelector.charAt(i);\n            if (i === vnodeSelector.length || c === '.' || c === '#') {\n                type = vnodeSelector.charAt(start - 1);\n                found = vnodeSelector.slice(start, i);\n                if (type === '.') {\n                    domNode.classList.add(found);\n                }\n                else if (type === '#') {\n                    domNode.id = found;\n                }\n                else {\n                    if (found === 'svg') {\n                        projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                    }\n                    if (projectionOptions.namespace !== undefined) {\n                        domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                    }\n                    else {\n                        domNode = vnode.domNode = document.createElement(found);\n                    }\n                    if (insertBefore !== undefined) {\n                        parentNode.insertBefore(domNode, insertBefore);\n                    }\n                    else {\n                        parentNode.appendChild(domNode);\n                    }\n                }\n                start = i + 1;\n            }\n        }\n        initPropertiesAndChildren(domNode, vnode, projectionOptions);\n    }\n};\nupdateDom = function (previous, vnode, projectionOptions) {\n    var domNode = previous.domNode;\n    var textUpdated = false;\n    if (previous === vnode) {\n        return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\n    }\n    var updated = false;\n    if (vnode.vnodeSelector === '') {\n        if (vnode.text !== previous.text) {\n            var newVNode = document.createTextNode(vnode.text);\n            domNode.parentNode.replaceChild(newVNode, domNode);\n            vnode.domNode = newVNode;\n            textUpdated = true;\n            return textUpdated;\n        }\n    }\n    else {\n        if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n        }\n        if (previous.text !== vnode.text) {\n            updated = true;\n            if (vnode.text === undefined) {\n                domNode.removeChild(domNode.firstChild); // the only textnode presumably\n            }\n            else {\n                domNode.textContent = vnode.text;\n            }\n        }\n        updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n        updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n        if (vnode.properties && vnode.properties.afterUpdate) {\n            vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n        }\n    }\n    if (updated && vnode.properties && vnode.properties.updateAnimation) {\n        vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n    }\n    vnode.domNode = previous.domNode;\n    return textUpdated;\n};\nvar createProjection = function (vnode, projectionOptions) {\n    return {\n        update: function (updatedVnode) {\n            if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n            }\n            updateDom(vnode, updatedVnode, projectionOptions);\n            vnode = updatedVnode;\n        },\n        domNode: vnode.domNode\n    };\n};\n;\n// The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\nexports.h = function (selector) {\n    var properties = arguments[1];\n    if (typeof selector !== 'string') {\n        throw new Error();\n    }\n    var childIndex = 1;\n    if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n        childIndex = 2;\n    }\n    else {\n        // Optional properties argument was omitted\n        properties = undefined;\n    }\n    var text = undefined;\n    var children = undefined;\n    var argsLength = arguments.length;\n    // Recognize a common special case where there is only a single text node\n    if (argsLength === childIndex + 1) {\n        var onlyChild = arguments[childIndex];\n        if (typeof onlyChild === 'string') {\n            text = onlyChild;\n        }\n        else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n            text = onlyChild[0];\n        }\n    }\n    if (text === undefined) {\n        children = [];\n        for (; childIndex < argsLength; childIndex++) {\n            var child = arguments[childIndex];\n            if (child === null || child === undefined) {\n                continue;\n            }\n            else if (Array.isArray(child)) {\n                appendChildren(selector, child, children);\n            }\n            else if (child.hasOwnProperty('vnodeSelector')) {\n                children.push(child);\n            }\n            else {\n                children.push(toTextVNode(child));\n            }\n        }\n    }\n    return {\n        vnodeSelector: selector,\n        properties: properties,\n        children: children,\n        text: (text === '') ? undefined : text,\n        domNode: null\n    };\n};\n/**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\nexports.dom = {\n    /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n    create: function (vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n    append: function (parentNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, parentNode, undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    insertBefore: function (beforeNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    merge: function (element, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        vnode.domNode = element;\n        initPropertiesAndChildren(element, vnode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    }\n};\n/**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\nexports.createCache = function () {\n    var cachedInputs = undefined;\n    var cachedOutcome = undefined;\n    var result = {\n        invalidate: function () {\n            cachedOutcome = undefined;\n            cachedInputs = undefined;\n        },\n        result: function (inputs, calculation) {\n            if (cachedInputs) {\n                for (var i = 0; i < inputs.length; i++) {\n                    if (cachedInputs[i] !== inputs[i]) {\n                        cachedOutcome = undefined;\n                    }\n                }\n            }\n            if (!cachedOutcome) {\n                cachedOutcome = calculation();\n                cachedInputs = inputs;\n            }\n            return cachedOutcome;\n        }\n    };\n    return result;\n};\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\nexports.createMapping = function (getSourceKey, createResult, updateResult) {\n    var keys = [];\n    var results = [];\n    return {\n        results: results,\n        map: function (newSources) {\n            var newKeys = newSources.map(getSourceKey);\n            var oldTargets = results.slice();\n            var oldIndex = 0;\n            for (var i = 0; i < newSources.length; i++) {\n                var source = newSources[i];\n                var sourceKey = newKeys[i];\n                if (sourceKey === keys[oldIndex]) {\n                    results[i] = oldTargets[oldIndex];\n                    updateResult(source, oldTargets[oldIndex], i);\n                    oldIndex++;\n                }\n                else {\n                    var found = false;\n                    for (var j = 1; j < keys.length + 1; j++) {\n                        var searchIndex = (oldIndex + j) % keys.length;\n                        if (keys[searchIndex] === sourceKey) {\n                            results[i] = oldTargets[searchIndex];\n                            updateResult(newSources[i], oldTargets[searchIndex], i);\n                            oldIndex = searchIndex + 1;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        results[i] = createResult(source, i);\n                    }\n                }\n            }\n            results.length = newSources.length;\n            keys = newKeys;\n        }\n    };\n};\n/**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\nexports.createProjector = function (projectorOptions) {\n    var projector;\n    var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n    projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n        return function () {\n            // intercept function calls (event handlers) to do a render afterwards.\n            projector.scheduleRender();\n            return eventHandler.apply(properties.bind || this, arguments);\n        };\n    };\n    var renderCompleted = true;\n    var scheduled;\n    var stopped = false;\n    var projections = [];\n    var renderFunctions = []; // matches the projections array\n    var doRender = function () {\n        scheduled = undefined;\n        if (!renderCompleted) {\n            return; // The last render threw an error, it should be logged in the browser console.\n        }\n        renderCompleted = false;\n        for (var i = 0; i < projections.length; i++) {\n            var updatedVnode = renderFunctions[i]();\n            projections[i].update(updatedVnode);\n        }\n        renderCompleted = true;\n    };\n    projector = {\n        scheduleRender: function () {\n            if (!scheduled && !stopped) {\n                scheduled = requestAnimationFrame(doRender);\n            }\n        },\n        stop: function () {\n            if (scheduled) {\n                cancelAnimationFrame(scheduled);\n                scheduled = undefined;\n            }\n            stopped = true;\n        },\n        resume: function () {\n            stopped = false;\n            renderCompleted = true;\n            projector.scheduleRender();\n        },\n        append: function (parentNode, renderMaquetteFunction) {\n            projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        insertBefore: function (beforeNode, renderMaquetteFunction) {\n            projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        merge: function (domNode, renderMaquetteFunction) {\n            projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        replace: function (domNode, renderMaquetteFunction) {\n            var vnode = renderMaquetteFunction();\n            createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n            domNode.parentNode.removeChild(domNode);\n            projections.push(createProjection(vnode, projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        detach: function (renderMaquetteFunction) {\n            for (var i = 0; i < renderFunctions.length; i++) {\n                if (renderFunctions[i] === renderMaquetteFunction) {\n                    renderFunctions.splice(i, 1);\n                    return projections.splice(i, 1)[0];\n                }\n            }\n            throw new Error('renderMaquetteFunction was not found');\n        }\n    };\n    return projector;\n};\n\n//# sourceMappingURL=maquette.js.map\n","// Comment that is displayed in the API documentation for the maquette module:\n/**\n * Welcome to the API documentation of the **maquette** library.\n *\n * [[http://maquettejs.org/|To the maquette homepage]]\n */\n\n/**\n * A virtual representation of a DOM Node. Maquette assumes that [[VNode]] objects are never modified externally.\n * Instances of [[VNode]] can be created using [[h]].\n */\nexport interface VNode {\n  /**\n   * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node.\n   */\n  vnodeSelector: string;\n  /**\n   * Object containing attributes, properties, event handlers and more, see [[h]].\n   */\n  properties: VNodeProperties;\n  /**\n   * Array of [[VNode]]s to be used as children. This array is already flattened.\n   */\n  children: Array<VNode>;\n  /**\n   * Used in a special case when a [[VNode]] only has one childnode which is a textnode. Only used in combination with children === undefined.\n   */\n  text: string;\n  /**\n   * Used by maquette to store the domNode that was produced from this [[VNode]].\n   */\n  domNode: Node;\n}\n\n/**\n * A projector is used to create the real DOM from the the virtual DOM and to keep it up-to-date afterwards.\n *\n * You can call [[append]], [[merge]], [[insertBefore]] and [[replace]] to add the virtual DOM to the real DOM.\n * The `renderMaquetteFunction` callbacks will be called to create the real DOM immediately.\n * Afterwards, the `renderMaquetteFunction` callbacks will be called again to update the DOM on the next animation-frame after:\n *\n *  - The Projector's [[scheduleRender]] function  was called\n *  - An event handler (like `onclick`) on a rendered [[VNode]] was called.\n *\n * The projector stops when [[stop]] is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of [[Projector]] can be created using [[createProjector]].\n */\nexport interface Projector {\n  /**\n   * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param parentNode - The parent node for the new childNode.\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\n   */\n  append(parentNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param beforeNode - The node that the DOM Node is inserted before.\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\n   */\n  insertBefore(beforeNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\n   * This means that the virtual DOM and real DOM have one overlapping element.\n   * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\n   */\n  merge(domNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param domNode - The DOM node to replace.\n   * @param renderMaquetteFunction - Function with zero arguments that returns a [[VNode]] tree.\n   */\n  replace(domNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Resumes the projector. Use this method to resume rendering after [[stop]] was called or an error occurred during rendering.\n   */\n  resume(): void;\n  /**\n   * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\n   * This method is automatically called for you when event-handlers that are registered in the [[VNode]]s are invoked.\n   *\n   * You need to call this method when timeouts expire, when AJAX responses arrive or other asynchronous actions happen.\n   */\n  scheduleRender(): void;\n  /**\n   * Stops running the `renderMaquetteFunction` to update the DOM. The `renderMaquetteFunction` must have been\n   * registered using [[append]], [[merge]], [[insertBefore]] or [[replace]].\n   *\n   * @returns The [[Projection]] which was created using this `renderMaquetteFunction`.\n   * The [[Projection]] contains a reference to the DOM Node that was rendered.\n   */\n  detach(renderMaquetteFunction: () => VNode): Projection;\n  /**\n   * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\n   *\n   * Note that calling [[stop]] is not mandatory. A projector is a passive object that will get garbage collected\n   * as usual if it is no longer in scope.\n   */\n  stop(): void;\n}\n\n/**\n * These functions are called when [[VNodeProperties.enterAnimation]] and [[VNodeProperties.exitAnimation]] are provided as strings.\n * See [[ProjectionOptions.transitions]].\n */\nexport interface TransitionStrategy {\n  /**\n   * Function that is called when a [[VNode]] with an `enterAnimation` string is added to an already existing parent [[VNode]].\n   *\n   * @param element         Element that was just added to the DOM.\n   * @param properties      The properties object that was supplied to the [[h]] method\n   * @param enterAnimation  The string that was passed to [[VNodeProperties.enterAnimation]].\n   */\n  enter(element: Element, properties: VNodeProperties, enterAnimation: string): void;\n  /**\n   * Function that is called when a [[VNode]] with an `exitAnimation` string is removed from a existing parent [[VNode]] that remains.\n   *\n   * @param element         Element that ought to be removed from to the DOM.\n   * @param properties      The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\n   * @param exitAnimation   The string that was passed to [[VNodeProperties.exitAnimation]].\n   * @param removeElement   Function that removes the element from the DOM.\n   *                        This argument is provided purely for convenience.\n   *                        You may use this function to remove the element when the animation is done.\n   */\n  exit(element: Element, properties: VNodeProperties, exitAnimation: string, removeElement: () => void): void;\n};\n\n/**\n * Options that may be passed when creating the [[Projector]]\n */\nexport interface ProjectorOptions {\n  /**\n   * A transition strategy to invoke when enterAnimation and exitAnimation properties are provided as strings.\n   * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\n   * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\n   */\n  transitions?: TransitionStrategy;\n  /**\n   * May be used to add vendor prefixes when applying inline styles when needed.\n   * This function is called when [[styles]] is used.\n   * This function should execute `domNode.style[styleName] = value` or do something smarter.\n   *\n   * @param domNode   The DOM Node that needs to receive the style\n   * @param styleName The name of the style that should be applied, for example `transform`.\n   * @param value     The value of this style, for example `rotate(45deg)`.\n   */\n  styleApplyer?(domNode: HTMLElement, styleName: string, value: string): void;\n};\n\n/**\n * Options that influence how the DOM is rendered and updated.\n */\nexport interface ProjectionOptions extends ProjectorOptions {\n  /**\n   * Only for internal use. Used for rendering SVG Nodes.\n   */\n  namespace?: string;\n  /**\n   * May be used to intercept registration of event-handlers.\n   *\n   * Used by the [[Projector]] to wrap eventHandler-calls to call [[scheduleRender]] as well.\n   *\n   * @param propertyName             The name of the property to be assigned, for example onclick\n   * @param eventHandler             The function that was registered on the [[VNode]]\n   * @param domNode                  The real DOM element\n   * @param properties               The whole set of properties that was put on the VNode\n   * @returns                        The function that is to be placed on the DOM node as the event handler, instead of `eventHandler`.\n   */\n  eventHandlerInterceptor?: (propertyName: string, eventHandler: Function, domNode: Node, properties: VNodeProperties) => Function;\n};\n\n/**\n * Object containing attributes, properties, event handlers and more that can be put on DOM nodes.\n *\n * For your convenience, all common attributes, properties and event handlers are listed here and are\n * type-checked when using Typescript.\n */\nexport interface VNodeProperties {\n  /**\n   * The animation to perform when this node is added to an already existing parent.\n   * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the\n   * projector using [[createProjector]].\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n   * @param element - Element that was just added to the DOM.\n   * @param properties - The properties object that was supplied to the [[h]] method\n   */\n  enterAnimation?: ((element: Element, properties?: VNodeProperties) => void) | string;\n  /**\n   * The animation to perform when this node is removed while its parent remains.\n   * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector using [[createProjector]].\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n   * @param element - Element that ought to be removed from to the DOM.\n   * @param removeElement - Function that removes the element from the DOM.\n   * This argument is provided purely for convenience.\n   * You may use this function to remove the element when the animation is done.\n   * @param properties - The properties object that was supplied to the [[h]] method that rendered this [[VNode]] the previous time.\n   */\n  exitAnimation?: ((element: Element, removeElement: () => void, properties?: VNodeProperties) => void) | string;\n  /**\n   * The animation to perform when the properties of this node change.\n   * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n   * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n   * @param element - Element that was modified in the DOM.\n   * @param properties - The last properties object that was supplied to the [[h]] method\n   * @param previousProperties - The previous properties object that was supplied to the [[h]] method\n   */\n  updateAnimation?: (element: Element, properties?: VNodeProperties, previousProperties?: VNodeProperties) => void;\n  /**\n   * Callback that is executed after this node is added to the DOM. Childnodes and properties have\n   * already been applied.\n   * @param element - The element that was added to the DOM.\n   * @param projectionOptions - The projection options that were used see [[createProjector]].\n   * @param vnodeSelector - The selector passed to the [[h]] function.\n   * @param properties - The properties passed to the [[h]] function.\n   * @param children - The children that were created.\n   * @param properties - The last properties object that was supplied to the [[h]] method\n   * @param previousProperties - The previous properties object that was supplied to the [[h]] method\n   */\n  afterCreate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n    children: VNode[]): void;\n  /**\n   * Callback that is executed every time this node may have been updated. Childnodes and properties\n   * have already been updated.\n   * @param element - The element that may have been updated in the DOM.\n   * @param projectionOptions - The projection options that were used see [[createProjector]].\n   * @param vnodeSelector - The selector passed to the [[h]] function.\n   * @param properties - The properties passed to the [[h]] function.\n   * @param children - The children for this node.\n   */\n  afterUpdate?(element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n    children: VNode[]): void;\n  /**\n   * When specified, the event handlers will be invoked with 'this' pointing to the value.\n   * This is useful when using the prototype/class based implementation of Components.\n   *\n   * When no [[key]] is present, this object is also used to uniquely identify a DOM node.\n   */\n  bind?: Object;\n  /**\n   * Used to uniquely identify a DOM node among siblings.\n   * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n   * NOTE: this does not have to be a string or number, a [[Component]] Object for instance is also possible.\n   */\n  key?: Object;\n  /**\n   * An object literal like `{important:true}` which allows css classes, like `important` to be added and removed\n   * dynamically.\n   */\n  classes?: { [index: string]: boolean };\n  /**\n   * An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\n   */\n  styles?: { [index: string]: string };\n\n  // From Element\n  ontouchcancel?(ev?: TouchEvent): boolean | void;\n  ontouchend?(ev?: TouchEvent): boolean | void;\n  ontouchmove?(ev?: TouchEvent): boolean | void;\n  ontouchstart?(ev?: TouchEvent): boolean | void;\n  // From HTMLFormElement\n  action?: string;\n  encoding?: string;\n  enctype?: string;\n  method?: string;\n  name?: string;\n  target?: string;\n  // From HTMLElement\n  onblur?(ev?: FocusEvent): boolean | void;\n  onchange?(ev?: Event): boolean | void;\n  onclick?(ev?: MouseEvent): boolean | void;\n  ondblclick?(ev?: MouseEvent): boolean | void;\n  onfocus?(ev?: FocusEvent): boolean | void;\n  oninput?(ev?: Event): boolean | void;\n  onkeydown?(ev?: KeyboardEvent): boolean | void;\n  onkeypress?(ev?: KeyboardEvent): boolean | void;\n  onkeyup?(ev?: KeyboardEvent): boolean | void;\n  onload?(ev?: Event): boolean | void;\n  onmousedown?(ev?: MouseEvent): boolean | void;\n  onmouseenter?(ev?: MouseEvent): boolean | void;\n  onmouseleave?(ev?: MouseEvent): boolean | void;\n  onmousemove?(ev?: MouseEvent): boolean | void;\n  onmouseout?(ev?: MouseEvent): boolean | void;\n  onmouseover?(ev?: MouseEvent): boolean | void;\n  onmouseup?(ev?: MouseEvent): boolean | void;\n  onmousewheel?(ev?: MouseWheelEvent): boolean | void;\n  onscroll?(ev?: UIEvent): boolean | void;\n  onsubmit?(ev?: Event): boolean | void;\n  spellcheck?: boolean;\n  tabIndex?: number;\n  title?: string;\n  accessKey?: string;\n  id?: string;\n  // From HTMLInputElement\n  autocomplete?: string;\n  checked?: boolean;\n  placeholder?: string;\n  readOnly?: boolean;\n  src?: string;\n  value?: string;\n  // From HTMLImageElement\n  alt?: string;\n  srcset?: string;\n  /**\n   * Puts a non-interactive piece of html inside the DOM node.\n   *\n   * Note: if you use innerHTML, maquette cannot protect you from XSS vulnerabilities and you must make sure that the innerHTML value is safe.\n   */\n  innerHTML?: string;\n\n  /**\n   * Everything that is not explicitly listed (properties and attributes that are either uncommon or custom).\n   */\n  [index: string]: any;\n};\n\n/**\n * Represents a [[VNode]] tree that has been rendered to a real DOM tree.\n */\nexport interface Projection {\n  /**\n   * The DOM node that is used as the root of this [[Projection]].\n   */\n  domNode: Element;\n  /**\n   * Updates the real DOM to match the new virtual DOM tree.\n   * @param updatedVnode The updated virtual DOM tree. Note: The selector for the root of the [[VNode]] tree may not change.\n   */\n  update(updatedVnode: VNode): void;\n}\n\nconst NAMESPACE_W3 = 'http://www.w3.org/';\nconst NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\nconst NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n\n// Utilities\n\nlet emptyArray = <VNode[]>[];\n\nlet extend = <T>(base: T, overrides: any): T => {\n  let result = {} as any;\n  Object.keys(base).forEach(function(key) {\n    result[key] = (base as any)[key];\n  });\n  if (overrides) {\n    Object.keys(overrides).forEach((key) => {\n      result[key] = overrides[key];\n    });\n  }\n  return result;\n};\n\n// Hyperscript helper functions\n\nlet same = (vnode1: VNode, vnode2: VNode) => {\n  if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n    return false;\n  }\n  if (vnode1.properties && vnode2.properties) {\n    if (vnode1.properties.key !== vnode2.properties.key) {\n      return false;\n    }\n    return vnode1.properties.bind === vnode2.properties.bind;\n  }\n  return !vnode1.properties && !vnode2.properties;\n};\n\nlet toTextVNode = (data: any): VNode => {\n  return {\n    vnodeSelector: '',\n    properties: undefined,\n    children: undefined,\n    text: data.toString(),\n    domNode: null\n  };\n};\n\nlet appendChildren = function(parentSelector: string, insertions: any[], main: VNode[]) {\n  for (let i = 0, length = insertions.length; i < length; i++) {\n    let item = insertions[i];\n    if (Array.isArray(item)) {\n      appendChildren(parentSelector, item, main);\n    } else {\n      if (item !== null && item !== undefined) {\n        if (!item.hasOwnProperty('vnodeSelector')) {\n          item = toTextVNode(item);\n        }\n        main.push(item);\n      }\n    }\n  }\n};\n\n// Render helper functions\n\nlet missingTransition = function() {\n  throw new Error('Provide a transitions object to the projectionOptions to do animations');\n};\n\nconst DEFAULT_PROJECTION_OPTIONS: ProjectionOptions = {\n  namespace: undefined,\n  eventHandlerInterceptor: undefined,\n  styleApplyer: function(domNode: HTMLElement, styleName: string, value: string) {\n    // Provides a hook to add vendor prefixes for browsers that still need it.\n    (domNode.style as any)[styleName] = value;\n  },\n  transitions: {\n    enter: missingTransition,\n    exit: missingTransition\n  }\n};\n\nlet applyDefaultProjectionOptions = (projectorOptions: ProjectionOptions) => {\n  return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n};\n\nlet checkStyleValue = (styleValue: Object) => {\n  if (typeof styleValue !== 'string') {\n    throw new Error('Style values must be strings');\n  }\n};\n\nlet setProperties = function(domNode: Node, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\n  if (!properties) {\n    return;\n  }\n  let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n  let propNames = Object.keys(properties);\n  let propCount = propNames.length;\n  for (let i = 0; i < propCount; i++) {\n    let propName = propNames[i];\n    /* tslint:disable:no-var-keyword: edge case */\n    var propValue = properties[propName];\n    /* tslint:enable:no-var-keyword */\n    if (propName === 'className') {\n      throw new Error('Property \"className\" is not supported, use \"class\".');\n    } else if (propName === 'class') {\n      (propValue as string).split(/\\s+/).forEach(token => (domNode as Element).classList.add(token));\n    } else if (propName === 'classes') {\n      // object with string keys and boolean values\n      let classNames = Object.keys(propValue);\n      let classNameCount = classNames.length;\n      for (let j = 0; j < classNameCount; j++) {\n        let className = classNames[j];\n        if (propValue[className]) {\n          (domNode as Element).classList.add(className);\n        }\n      }\n    } else if (propName === 'styles') {\n      // object with string keys and string (!) values\n      let styleNames = Object.keys(propValue);\n      let styleCount = styleNames.length;\n      for (let j = 0; j < styleCount; j++) {\n        let styleName = styleNames[j];\n        let styleValue = propValue[styleName];\n        if (styleValue) {\n          checkStyleValue(styleValue);\n          projectionOptions.styleApplyer(<HTMLElement>domNode, styleName, styleValue);\n        }\n      }\n    } else if (propName === 'key') {\n      continue;\n    } else if (propValue === null || propValue === undefined) {\n      continue;\n    } else {\n      let type = typeof propValue;\n      if (type === 'function') {\n        if (propName.lastIndexOf('on', 0) === 0) { // lastIndexOf(,0)===0 -> startsWith\n          if (eventHandlerInterceptor) {\n            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n          }\n          if (propName === 'oninput') {\n            (function() {\n              // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n              let oldPropValue = propValue;\n              propValue = function(evt: Event) {\n                (evt.target as any)['oninput-value'] = (evt.target as HTMLInputElement).value; // may be HTMLTextAreaElement as well\n                oldPropValue.apply(this, [evt]);\n              };\n            } ());\n          }\n          (domNode as any)[propName] = propValue;\n        }\n      } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n          (domNode as Element).setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n        } else {\n          (domNode as Element).setAttribute(propName, propValue);\n        }\n      } else {\n        (domNode as any)[propName] = propValue;\n      }\n    }\n  }\n};\n\nlet updateProperties = function(domNode: Node, previousProperties: VNodeProperties, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\n  if (!properties) {\n    return;\n  }\n  let propertiesUpdated = false;\n  let propNames = Object.keys(properties);\n  let propCount = propNames.length;\n  for (let i = 0; i < propCount; i++) {\n    let propName = propNames[i];\n    // assuming that properties will be nullified instead of missing is by design\n    let propValue = properties[propName];\n    let previousValue = previousProperties[propName];\n    if (propName === 'class') {\n      if (previousValue !== propValue) {\n        throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n      }\n    } else if (propName === 'classes') {\n      let classList = (domNode as Element).classList;\n      let classNames = Object.keys(propValue);\n      let classNameCount = classNames.length;\n      for (let j = 0; j < classNameCount; j++) {\n        let className = classNames[j];\n        let on = !!propValue[className];\n        let previousOn = !!previousValue[className];\n        if (on === previousOn) {\n          continue;\n        }\n        propertiesUpdated = true;\n        if (on) {\n          classList.add(className);\n        } else {\n          classList.remove(className);\n        }\n      }\n    } else if (propName === 'styles') {\n      let styleNames = Object.keys(propValue);\n      let styleCount = styleNames.length;\n      for (let j = 0; j < styleCount; j++) {\n        let styleName = styleNames[j];\n        let newStyleValue = propValue[styleName];\n        let oldStyleValue = previousValue[styleName];\n        if (newStyleValue === oldStyleValue) {\n          continue;\n        }\n        propertiesUpdated = true;\n        if (newStyleValue) {\n          checkStyleValue(newStyleValue);\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, newStyleValue);\n        } else {\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, '');\n        }\n      }\n    } else {\n      if (!propValue && typeof previousValue === 'string') {\n        propValue = '';\n      }\n      if (propName === 'value') { // value can be manipulated by the user directly and using event.preventDefault() is not an option\n        if ((domNode as any)[propName] !== propValue && (domNode as any)['oninput-value'] !== propValue) {\n          (domNode as any)[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n          (domNode as any)['oninput-value'] = undefined;\n        } // else do not update the domNode, otherwise the cursor position would be changed\n        if (propValue !== previousValue) {\n          propertiesUpdated = true;\n        }\n      } else if (propValue !== previousValue) {\n        let type = typeof propValue;\n        if (type === 'function') {\n          throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\n            '). Hint: declare event handler functions outside the render() function.');\n        }\n        if (type === 'string' && propName !== 'innerHTML') {\n          if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n            (domNode as Element).setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n          } else {\n            (domNode as Element).setAttribute(propName, propValue);\n          }\n        } else {\n          if ((domNode as any)[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\n            (domNode as any)[propName] = propValue;\n          }\n        }\n        propertiesUpdated = true;\n      }\n    }\n  }\n  return propertiesUpdated;\n};\n\nlet findIndexOfChild = function(children: VNode[], sameAs: VNode, start: number) {\n  if (sameAs.vnodeSelector !== '') {\n    // Never scan for text-nodes\n    for (let i = start; i < children.length; i++) {\n      if (same(children[i], sameAs)) {\n        return i;\n      }\n    }\n  }\n  return -1;\n};\n\nlet nodeAdded = function(vNode: VNode, transitions: TransitionStrategy) {\n  if (vNode.properties) {\n    let enterAnimation = vNode.properties.enterAnimation;\n    if (enterAnimation) {\n      if (typeof enterAnimation === 'function') {\n        enterAnimation(vNode.domNode as Element, vNode.properties);\n      } else {\n        transitions.enter(vNode.domNode as Element, vNode.properties, enterAnimation as string);\n      }\n    }\n  }\n};\n\nlet nodeToRemove = function(vNode: VNode, transitions: TransitionStrategy) {\n  let domNode = vNode.domNode;\n  if (vNode.properties) {\n    let exitAnimation = vNode.properties.exitAnimation;\n    if (exitAnimation) {\n      (domNode as HTMLElement).style.pointerEvents = 'none';\n      let removeDomNode = function() {\n        if (domNode.parentNode) {\n          domNode.parentNode.removeChild(domNode);\n        }\n      };\n      if (typeof exitAnimation === 'function') {\n        exitAnimation(domNode as Element, removeDomNode, vNode.properties);\n        return;\n      } else {\n        transitions.exit(vNode.domNode as Element, vNode.properties, exitAnimation as string, removeDomNode);\n        return;\n      }\n    }\n  }\n  if (domNode.parentNode) {\n    domNode.parentNode.removeChild(domNode);\n  }\n};\n\nlet checkDistinguishable = function(childNodes: VNode[], indexToCheck: number, parentVNode: VNode, operation: string) {\n  let childNode = childNodes[indexToCheck];\n  if (childNode.vnodeSelector === '') {\n    return; // Text nodes need not be distinguishable\n  }\n  let properties = childNode.properties;\n  let key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;\n  if (!key) { // A key is just assumed to be unique\n    for (let i = 0; i < childNodes.length; i++) {\n      if (i !== indexToCheck) {\n        let node = childNodes[i];\n        if (same(node, childNode)) {\n          if (operation === 'added') {\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n              'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n          } else {\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n              'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n          }\n        }\n      }\n    }\n  }\n};\n\nlet createDom: (vnode: VNode, parentNode: Node, insertBefore: Node, projectionOptions: ProjectionOptions) => void;\nlet updateDom: (previous: VNode, vnode: VNode, projectionOptions: ProjectionOptions) => boolean;\n\nlet updateChildren = function(vnode: VNode, domNode: Node, oldChildren: VNode[], newChildren: VNode[], projectionOptions: ProjectionOptions) {\n  if (oldChildren === newChildren) {\n    return false;\n  }\n  oldChildren = oldChildren || emptyArray;\n  newChildren = newChildren || emptyArray;\n  let oldChildrenLength = oldChildren.length;\n  let newChildrenLength = newChildren.length;\n  let transitions = projectionOptions.transitions;\n\n  let oldIndex = 0;\n  let newIndex = 0;\n  let i: number;\n  let textUpdated = false;\n  while (newIndex < newChildrenLength) {\n    let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\n    let newChild = newChildren[newIndex];\n    if (oldChild !== undefined && same(oldChild, newChild)) {\n      textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n      oldIndex++;\n    } else {\n      let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n      if (findOldIndex >= 0) {\n        // Remove preceding missing children\n        for (i = oldIndex; i < findOldIndex; i++) {\n          nodeToRemove(oldChildren[i], transitions);\n          checkDistinguishable(oldChildren, i, vnode, 'removed');\n        }\n        textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n        oldIndex = findOldIndex + 1;\n      } else {\n        // New child\n        createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n        nodeAdded(newChild, transitions);\n        checkDistinguishable(newChildren, newIndex, vnode, 'added');\n      }\n    }\n    newIndex++;\n  }\n  if (oldChildrenLength > oldIndex) {\n    // Remove child fragments\n    for (i = oldIndex; i < oldChildrenLength; i++) {\n      nodeToRemove(oldChildren[i], transitions);\n      checkDistinguishable(oldChildren, i, vnode, 'removed');\n    }\n  }\n  return textUpdated;\n};\n\nlet addChildren = function(domNode: Node, children: VNode[], projectionOptions: ProjectionOptions) {\n  if (!children) {\n    return;\n  }\n  for (let i = 0; i < children.length; i++) {\n    createDom(children[i], domNode, undefined, projectionOptions);\n  }\n};\n\nlet initPropertiesAndChildren = function(domNode: Node, vnode: VNode, projectionOptions: ProjectionOptions) {\n  addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n  if (vnode.text) {\n    domNode.textContent = vnode.text;\n  }\n  setProperties(domNode, vnode.properties, projectionOptions);\n  if (vnode.properties && vnode.properties.afterCreate) {\n    vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode as Element, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n  }\n};\n\ncreateDom = function(vnode, parentNode, insertBefore, projectionOptions) {\n  let domNode: Node, i: number, c: string, start = 0, type: string, found: string;\n  let vnodeSelector = vnode.vnodeSelector;\n  if (vnodeSelector === '') {\n    domNode = vnode.domNode = document.createTextNode(vnode.text);\n    if (insertBefore !== undefined) {\n      parentNode.insertBefore(domNode, insertBefore);\n    } else {\n      parentNode.appendChild(domNode);\n    }\n  } else {\n    for (i = 0; i <= vnodeSelector.length; ++i) {\n      c = vnodeSelector.charAt(i);\n      if (i === vnodeSelector.length || c === '.' || c === '#') {\n        type = vnodeSelector.charAt(start - 1);\n        found = vnodeSelector.slice(start, i);\n        if (type === '.') {\n          (domNode as HTMLElement).classList.add(found);\n        } else if (type === '#') {\n          (domNode as Element).id = found;\n        } else {\n          if (found === 'svg') {\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n          }\n          if (projectionOptions.namespace !== undefined) {\n            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n          } else {\n            domNode = vnode.domNode = document.createElement(found);\n          }\n          if (insertBefore !== undefined) {\n            parentNode.insertBefore(domNode, insertBefore);\n          } else {\n            parentNode.appendChild(domNode);\n          }\n        }\n        start = i + 1;\n      }\n    }\n    initPropertiesAndChildren(domNode, vnode, projectionOptions);\n  }\n};\n\nupdateDom = function(previous, vnode, projectionOptions) {\n  let domNode = previous.domNode;\n  let textUpdated = false;\n  if (previous === vnode) {\n    return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\n  }\n  let updated = false;\n  if (vnode.vnodeSelector === '') {\n    if (vnode.text !== previous.text) {\n      let newVNode = document.createTextNode(vnode.text);\n      domNode.parentNode.replaceChild(newVNode, domNode);\n      vnode.domNode = newVNode;\n      textUpdated = true;\n      return textUpdated;\n    }\n  } else {\n    if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\n      projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n    }\n    if (previous.text !== vnode.text) {\n      updated = true;\n      if (vnode.text === undefined) {\n        domNode.removeChild(domNode.firstChild); // the only textnode presumably\n      } else {\n        domNode.textContent = vnode.text;\n      }\n    }\n    updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n    updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n    if (vnode.properties && vnode.properties.afterUpdate) {\n      vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [<Element>domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n    }\n  }\n  if (updated && vnode.properties && vnode.properties.updateAnimation) {\n    vnode.properties.updateAnimation(<Element>domNode, vnode.properties, previous.properties);\n  }\n  vnode.domNode = previous.domNode;\n  return textUpdated;\n};\n\nlet createProjection = function(vnode: VNode, projectionOptions: ProjectionOptions): Projection {\n  return {\n    update: function(updatedVnode: VNode) {\n      if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n        throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n      }\n      updateDom(vnode, updatedVnode, projectionOptions);\n      vnode = updatedVnode;\n    },\n    domNode: <Element>vnode.domNode\n  };\n};\n\n// The following line is not possible in Typescript, hence the workaround in the two lines below\n// export type VNodeChild = string|VNode|Array<VNodeChild>\n/**\n * Only needed for the defintion of [[VNodeChild]].\n */\nexport interface VNodeChildren extends Array<VNodeChild> { };\n/**\n * These are valid values for the children parameter of the [[h]] function.\n */\nexport type VNodeChild = string | VNode | VNodeChildren;\n\n/**\n * Contains all valid method signatures for the [[h]] function.\n */\nexport interface H {\n  /**\n   * @param selector    Contains the tagName, id and fixed css classnames in CSS selector format.\n   *                    It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n   * @param properties  An object literal containing properties that will be placed on the DOM node.\n   * @param children    Virtual DOM nodes and strings to add as child nodes.\n   *                    `children` may contain [[VNode]]s, `string`s, nested arrays, `null` and `undefined`.\n   *                    Nested arrays are flattened, `null` and `undefined` are removed.\n   *\n   * @returns           A VNode object, used to render a real DOM later.\n   */\n  (selector: string, properties?: VNodeProperties, ...children: VNodeChild[]): VNode;\n  (selector: string, ...children: VNodeChild[]): VNode;\n}\n\n/**\n * The `h` function is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * All possible method signatures of this function can be found in the [[H]] 'interface'.\n *\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\n */\nexport let h: H;\n\n// The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\nh = function(selector: string): VNode {\n  let properties = arguments[1];\n  if (typeof selector !== 'string') {\n    throw new Error();\n  }\n  let childIndex = 1;\n  if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n    childIndex = 2;\n  } else {\n    // Optional properties argument was omitted\n    properties = undefined;\n  }\n  let text = undefined as string;\n  let children = undefined as VNode[];\n  let argsLength = arguments.length;\n  // Recognize a common special case where there is only a single text node\n  if (argsLength === childIndex + 1) {\n    let onlyChild = arguments[childIndex];\n    if (typeof onlyChild === 'string') {\n      text = onlyChild;\n    } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n      text = onlyChild[0];\n    }\n  }\n  if (text === undefined) {\n    children = [];\n    for (; childIndex < argsLength; childIndex++) {\n      let child = arguments[childIndex];\n      if (child === null || child === undefined) {\n        continue;\n      } else if (Array.isArray(child)) {\n        appendChildren(selector, child, children);\n      } else if (child.hasOwnProperty('vnodeSelector')) {\n        children.push(child);\n      } else {\n        children.push(toTextVNode(child));\n      }\n    }\n  }\n  return {\n    vnodeSelector: selector,\n    properties: properties,\n    children: children,\n    text: (text === '') ? undefined : text,\n    domNode: null\n  };\n};\n\n/**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\nexport let dom = {\n\n  /**\n   * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n   * its [[Projection.domNode|domNode]] property.\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n   * objects may only be rendered once.\n   * @param projectionOptions - Options to be used to create and update the projection.\n   * @returns The [[Projection]] which also contains the DOM Node that was created.\n   */\n  create: function(vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Appends a new childnode to the DOM which is generated from a [[VNode]].\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\n   * @param parentNode - The parent node for the new childNode.\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n   * objects may only be rendered once.\n   * @param projectionOptions - Options to be used to create and update the [[Projection]].\n   * @returns The [[Projection]] that was created.\n   */\n  append: function(parentNode: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, parentNode, undefined, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Inserts a new DOM node which is generated from a [[VNode]].\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\n   * @param beforeNode - The node that the DOM Node is inserted before.\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n   * NOTE: [[VNode]] objects may only be rendered once.\n   * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n   * @returns The [[Projection]] that was created.\n   */\n  insertBefore: function(beforeNode: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n   * This means that the virtual DOM and the real DOM will have one overlapping element.\n   * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n   * This is a low-level method. Users wil typically use a [[Projector]] instead.\n   * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n   * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n   * may only be rendered once.\n   * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n   * @returns The [[Projection]] that was created.\n   */\n  merge: function(element: Element, vnode: VNode, projectionOptions?: ProjectionOptions): Projection {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    vnode.domNode = element;\n    initPropertiesAndChildren(element, vnode, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  }\n\n};\n\n/**\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs.\n * On subsequent calls the previous outcome is returned if the inputs are identical.\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\n * Instances of CalculationCache can be created using [[createCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\nexport interface CalculationCache<Result> {\n  /**\n   * Manually invalidates the cached outcome.\n   */\n  invalidate(): void;\n  /**\n   * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\n   * Otherwise, the calculation function is invoked and its result is cached and returned.\n   * Objects in the inputs array are compared using ===.\n   * @param inputs - Array of objects that are to be compared using === with the inputs from the previous invocation.\n   * These objects are assumed to be immutable primitive values.\n   * @param calculation - Function that takes zero arguments and returns an object (A [[VNode]] assumably) that can be cached.\n   */\n  result(inputs: Object[], calculation: () => Result): Result;\n}\n\n/**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\nexport let createCache = <Result>(): CalculationCache<Result> => {\n  let cachedInputs = undefined as Object[];\n  let cachedOutcome = undefined as Result;\n  let result = {\n\n    invalidate: function() {\n      cachedOutcome = undefined;\n      cachedInputs = undefined;\n    },\n\n    result: function(inputs: Object[], calculation: () => Result) {\n      if (cachedInputs) {\n        for (let i = 0; i < inputs.length; i++) {\n          if (cachedInputs[i] !== inputs[i]) {\n            cachedOutcome = undefined;\n          }\n        }\n      }\n      if (!cachedOutcome) {\n        cachedOutcome = calculation();\n        cachedInputs = inputs;\n      }\n      return cachedOutcome;\n    }\n  };\n  return result;\n};\n\n/**\n * Keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * Mapping provides a [[map]] function that updates its [[results]].\n * The [[map]] function can be called multiple times and the results will get created, removed and updated accordingly.\n * A Mapping can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\n * Instances of Mapping can be created using [[createMapping]].\n *\n * @param <Source>   The type of source elements. Usually the data type.\n * @param <Target>   The type of target elements. Usually the component type.\n */\nexport interface Mapping<Source, Target> {\n  /**\n   * The array of results. These results will be synchronized with the latest array of sources that were provided using [[map]].\n   */\n  results: Array<Target>;\n  /**\n   * Maps a new array of sources and updates [[results]].\n   *\n   * @param newSources   The new array of sources.\n   */\n  map(newSources: Array<Source>): void;\n}\n\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\nexport let createMapping = <Source, Target>(\n  getSourceKey: (source: Source) => (string | number),\n  createResult: (source: Source, index: number) => Target,\n  updateResult: (source: Source, target: Target, index: number) => void): Mapping<Source, Target> => {\n  let keys = [] as Object[];\n  let results = [] as Target[];\n\n  return {\n    results: results,\n    map: function(newSources: Source[]) {\n      let newKeys = newSources.map(getSourceKey);\n      let oldTargets = results.slice();\n      let oldIndex = 0;\n      for (let i = 0; i < newSources.length; i++) {\n        let source = newSources[i];\n        let sourceKey = newKeys[i];\n        if (sourceKey === keys[oldIndex]) {\n          results[i] = oldTargets[oldIndex];\n          updateResult(source, oldTargets[oldIndex], i);\n          oldIndex++;\n        } else {\n          let found = false;\n          for (let j = 1; j < keys.length + 1; j++) {\n            let searchIndex = (oldIndex + j) % keys.length;\n            if (keys[searchIndex] === sourceKey) {\n              results[i] = oldTargets[searchIndex];\n              updateResult(newSources[i], oldTargets[searchIndex], i);\n              oldIndex = searchIndex + 1;\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            results[i] = createResult(source, i);\n          }\n        }\n      }\n      results.length = newSources.length;\n      keys = newKeys;\n    }\n  };\n};\n\n/**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\nexport let createProjector = function(projectorOptions: ProjectorOptions): Projector {\n  let projector: Projector;\n  let projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n  projectionOptions.eventHandlerInterceptor = function(propertyName: string, eventHandler: Function, domNode: Node, properties: VNodeProperties) {\n    return function() {\n      // intercept function calls (event handlers) to do a render afterwards.\n      projector.scheduleRender();\n      return eventHandler.apply(properties.bind || this, arguments);\n    };\n  };\n  let renderCompleted = true;\n  let scheduled: number;\n  let stopped = false;\n  let projections = [] as Projection[];\n  let renderFunctions = [] as (() => VNode)[]; // matches the projections array\n\n  let doRender = function() {\n    scheduled = undefined;\n    if (!renderCompleted) {\n      return; // The last render threw an error, it should be logged in the browser console.\n    }\n    renderCompleted = false;\n    for (let i = 0; i < projections.length; i++) {\n      let updatedVnode = renderFunctions[i]();\n      projections[i].update(updatedVnode);\n    }\n    renderCompleted = true;\n  };\n\n  projector = {\n    scheduleRender: function() {\n      if (!scheduled && !stopped) {\n        scheduled = requestAnimationFrame(doRender);\n      }\n    },\n    stop: function() {\n      if (scheduled) {\n        cancelAnimationFrame(scheduled);\n        scheduled = undefined;\n      }\n      stopped = true;\n    },\n\n    resume: function() {\n      stopped = false;\n      renderCompleted = true;\n      projector.scheduleRender();\n    },\n\n    append: function(parentNode, renderMaquetteFunction) {\n      projections.push(dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    insertBefore: function(beforeNode, renderMaquetteFunction) {\n      projections.push(dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    merge: function(domNode, renderMaquetteFunction) {\n      projections.push(dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    replace: function(domNode, renderMaquetteFunction) {\n      let vnode = renderMaquetteFunction();\n      createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n      domNode.parentNode.removeChild(domNode);\n      projections.push(createProjection(vnode, projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    detach: function(renderMaquetteFunction) {\n      for (let i = 0; i < renderFunctions.length; i++) {\n        if (renderFunctions[i] === renderMaquetteFunction) {\n          renderFunctions.splice(i, 1);\n          return projections.splice(i, 1)[0];\n        }\n      }\n      throw new Error('renderMaquetteFunction was not found');\n    }\n\n  };\n  return projector;\n};\n\n/**\n * A component is a pattern with which you can split up your web application into self-contained parts.\n *\n * A component may contain other components.\n * This can be achieved by calling the subcomponents `renderMaquette` functions during the [[renderMaquette]] function and by using the\n * resulting [[VNode]]s in the return value.\n *\n * This interface is not used anywhere in the maquette sourcecode, but this is a widely used pattern.\n */\nexport interface Component {\n  /**\n   * A function that returns the DOM representation of the component.\n   */\n  renderMaquette(): VNode;\n}\n"],"sourceRoot":"/source/"}