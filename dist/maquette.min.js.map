{"version":3,"sources":["../node_modules/browserify/node_modules/browser-pack/_prelude.js","src/maquette.ts"],"names":[],"mappings":"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","file":"maquette.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Utilities\r\n\r\nlet emptyArray = [];\r\n\r\nlet extend = function (base, overrides) {\r\n  let result = {};\r\n  Object.keys(base).forEach(function (key) {\r\n    result[key] = base[key];\r\n  });\r\n  if(overrides) {\r\n    Object.keys(overrides).forEach(function (key) {\r\n      result[key] = overrides[key];\r\n    });\r\n  }\r\n  return result;\r\n};\r\n\r\n// Hyperscript helper functions\r\n\r\nlet appendChildren = function (parentSelector, insertions, main) {\r\n  for(let i = 0; i < insertions.length; i++) {\r\n    let item = insertions[i];\r\n    if(Array.isArray(item)) {\r\n      appendChildren(parentSelector, item, main);\r\n    } else {\r\n      if(item !== null && item !== undefined) {\r\n        if(!item.hasOwnProperty(\"vnodeSelector\")) {\r\n          item = toTextVNode(item);\r\n        }\r\n        main.push(item);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet toTextVNode = function (data) {\r\n  return {\r\n    vnodeSelector: \"\",\r\n    properties: undefined,\r\n    children: undefined,\r\n    text: (data === null || data === undefined) ? \"\" : data.toString(),\r\n    domNode: null\r\n  };\r\n};\r\n\r\n// Render helper functions\r\n\r\nlet missingTransition = function() {\r\n  throw new Error(\"Provide a transitions object to the projectionOptions to do animations\");\r\n};\r\n\r\nlet defaultProjectionOptions = {\r\n  namespace: undefined,\r\n  eventHandlerInterceptor: undefined,\r\n  styleApplyer: function(domNode, styleName, value) {\r\n    // Provides a hook to add vendor prefixes for browsers that still need it.\r\n    domNode.style[styleName] = value;\r\n  },\r\n  transitions: {\r\n    enter: missingTransition,\r\n    exit: missingTransition\r\n  }\r\n};\r\n\r\nlet applyDefaultProjectionOptions = function (projectionOptions) {\r\n  return extend(defaultProjectionOptions, projectionOptions);\r\n};\r\n\r\nlet setProperties = function (domNode, properties, projectionOptions) {\r\n  if(!properties) {\r\n    return;\r\n  }\r\n  let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n  for(let propName in properties) {\r\n    var propValue = properties[propName];\r\n    if(propName === \"class\" || propName === \"className\" || propName === \"classList\") {\r\n      throw new Error(\"Property \" + propName + \" is not supported, use 'classes' instead.\");\r\n    } else if(propName === \"classes\") {\r\n      // object with string keys and boolean values\r\n      for(let className in propValue) {\r\n        if(propValue[className]) {\r\n          domNode.classList.add(className);\r\n        }\r\n      }\r\n    } else if(propName === \"styles\") {\r\n      // object with string keys and string (!) values\r\n      for(let styleName in propValue) {\r\n        let styleValue = propValue[styleName];\r\n        if(styleValue) {\r\n          if(typeof styleValue !== \"string\") {\r\n            throw new Error(\"Style values may only be strings\");\r\n          }\r\n          projectionOptions.styleApplyer(domNode, styleName, styleValue);\r\n        }\r\n      }\r\n    } else if(propName === \"key\") {\r\n      continue;\r\n    } else if(propValue === null || propValue === undefined) {\r\n      continue;\r\n    } else {\r\n      let type = typeof propValue;\r\n      if(type === \"function\") {\r\n        if(eventHandlerInterceptor && (propName.lastIndexOf(\"on\", 0) === 0)) { // lastIndexOf(,0)===0 -> startsWith\r\n          propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\r\n          if(propName === \"oninput\") {\r\n            (function () {\r\n              // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\r\n              let oldPropValue = propValue;\r\n              propValue = function (evt) {\r\n                evt.target[\"oninput-value\"] = evt.target.value;\r\n                oldPropValue.apply(this, [evt]);\r\n              };\r\n            }());\r\n          }\r\n        }\r\n        domNode[propName] = propValue;\r\n      } else if(type === \"string\" && propName !== \"value\") {\r\n        domNode.setAttribute(propName, propValue);\r\n      } else {\r\n        domNode[propName] = propValue;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\r\n  if(!properties) {\r\n    return;\r\n  }\r\n  let propertiesUpdated = false;\r\n  for(let propName in properties) {\r\n    // assuming that properties will be nullified instead of missing is by design\r\n    let propValue = properties[propName];\r\n    let previousValue = previousProperties[propName];\r\n    if(propName === \"classes\") {\r\n      let classList = domNode.classList;\r\n      for(let className in propValue) {\r\n        let on = !!propValue[className];\r\n        let previousOn = !!previousValue[className];\r\n        if(on === previousOn) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if(on) {\r\n          classList.add(className);\r\n        } else {\r\n          classList.remove(className);\r\n        }\r\n      }\r\n    } else if(propName === \"styles\") {\r\n      for(let styleName in propValue) {\r\n        let newStyleValue = propValue[styleName];\r\n        let oldStyleValue = previousValue[styleName];\r\n        if(newStyleValue === oldStyleValue) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if(newStyleValue) {\r\n          if(typeof newStyleValue !== \"string\") {\r\n            throw new Error(\"Style values may only be strings\");\r\n          }\r\n          projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\r\n        } else {\r\n          projectionOptions.styleApplyer(domNode, styleName, \"\");\r\n        }\r\n      }\r\n    } else {\r\n      if(!propValue && typeof previousValue === \"string\") {\r\n        propValue = \"\";\r\n      }\r\n      if(propName === \"value\") { // value can be manipulated by the user directly and using event.preventDefault() is not an option\r\n        if(domNode[propName] !== propValue && domNode[\"oninput-value\"] !== propValue) {\r\n          domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\r\n          domNode[\"oninput-value\"] = undefined;\r\n        } // else do not update the domNode, otherwise the cursor position would be changed\r\n        if(propValue !== previousValue) {\r\n          propertiesUpdated = true;\r\n        }\r\n      } else if(propValue !== previousValue) {\r\n        let type = typeof propValue;\r\n        if(type === \"function\") {\r\n          throw new Error(\"Functions may not be updated on subsequent renders (property: \" + propName +\r\n            \"). Hint: declare event handler functions outside the render() function.\");\r\n        }\r\n        if(type === \"string\") {\r\n          domNode.setAttribute(propName, propValue);\r\n        } else {\r\n          if(domNode[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\r\n            domNode[propName] = propValue;\r\n          }\r\n        }\r\n        propertiesUpdated = true;\r\n      }\r\n    }\r\n  }\r\n  return propertiesUpdated;\r\n};\r\n\r\nlet addChildren = function (domNode, children, projectionOptions) {\r\n  if(!children) {\r\n    return;\r\n  }\r\n  for(let i = 0; i < children.length; i++) {\r\n    createDom(children[i], domNode, undefined, projectionOptions);\r\n  }\r\n};\r\n\r\nlet same = function (vnode1, vnode2) {\r\n  if(vnode1.vnodeSelector !== vnode2.vnodeSelector) {\r\n    return false;\r\n  }\r\n  if(vnode1.properties && vnode2.properties) {\r\n    return vnode1.properties.key === vnode2.properties.key;\r\n  }\r\n  return !vnode1.properties && !vnode2.properties;\r\n};\r\n\r\nlet findIndexOfChild = function (children, sameAs, start) {\r\n  if(sameAs.vnodeSelector !== \"\") {\r\n    // Never scan for text-nodes\r\n    for(let i = start; i < children.length; i++) {\r\n      if(same(children[i], sameAs)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nlet nodeAdded = function (vNode, transitions) {\r\n  if(vNode.properties) {\r\n    let enterAnimation = vNode.properties.enterAnimation;\r\n    if(enterAnimation) {\r\n      if(typeof enterAnimation === \"function\") {\r\n        enterAnimation(vNode.domNode, vNode.properties);\r\n      } else {\r\n        transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet nodeToRemove = function (vNode, transitions) {\r\n  let domNode = vNode.domNode;\r\n  if(vNode.properties) {\r\n    let exitAnimation = vNode.properties.exitAnimation;\r\n    if(exitAnimation) {\r\n      domNode.style.pointerEvents = \"none\";\r\n      let removeDomNode = function () {\r\n        if(domNode.parentNode) {\r\n          domNode.parentNode.removeChild(domNode);\r\n        }\r\n      };\r\n      if(typeof exitAnimation === \"function\") {\r\n        exitAnimation(domNode, removeDomNode, vNode.properties);\r\n        return;\r\n      } else {\r\n        transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if(domNode.parentNode) {\r\n    domNode.parentNode.removeChild(domNode);\r\n  }\r\n};\r\n\r\nlet checkDistinguishable = function(childNodes, indexToCheck, parentVNode, operation) {\r\n  let childNode = childNodes[indexToCheck];\r\n  if (childNode.vnodeSelector === \"\") {\r\n    return; // Text nodes need not be distinguishable\r\n  }\r\n  let key = childNode.properties ? childNode.properties.key : undefined;\r\n  if (!key) { // A key is just assumed to be unique\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n      if (i !== indexToCheck) {\r\n        let node = childNodes[i];\r\n        if (same(node, childNode)) {\r\n          if (operation === \"added\") {\r\n            throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" +\r\n              \"added, but there is now more than one. You must add unique key properties to make them distinguishable.\");\r\n          } else {\r\n            throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" +\r\n              \"removed, but there were more than one. You must add unique key properties to make them distinguishable.\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\r\n  if(oldChildren === newChildren) {\r\n    return false;\r\n  }\r\n  oldChildren = oldChildren || emptyArray;\r\n  newChildren = newChildren || emptyArray;\r\n  let oldChildrenLength = oldChildren.length;\r\n  let newChildrenLength = newChildren.length;\r\n  let transitions = projectionOptions.transitions;\r\n\r\n  let oldIndex = 0;\r\n  let newIndex = 0;\r\n  let i;\r\n  let textUpdated = false;\r\n  while(newIndex < newChildrenLength) {\r\n    let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\r\n    let newChild = newChildren[newIndex];\r\n    if(oldChild !== undefined && same(oldChild, newChild)) {\r\n      textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\r\n      oldIndex++;\r\n    } else {\r\n      let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\r\n      if(findOldIndex >= 0) {\r\n        // Remove preceding missing children\r\n        for(i = oldIndex; i < findOldIndex; i++) {\r\n          nodeToRemove(oldChildren[i], transitions);\r\n          checkDistinguishable(oldChildren, i, vnode, \"removed\");\r\n        }\r\n        textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\r\n        oldIndex = findOldIndex + 1;\r\n      } else {\r\n        // New child\r\n        createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\r\n        nodeAdded(newChild, transitions);\r\n        checkDistinguishable(newChildren, newIndex, vnode, \"added\");\r\n      }\r\n    }\r\n    newIndex++;\r\n  }\r\n  if(oldChildrenLength > oldIndex) {\r\n    // Remove child fragments\r\n    for(i = oldIndex; i < oldChildrenLength; i++) {\r\n      nodeToRemove(oldChildren[i], transitions);\r\n      checkDistinguishable(oldChildren, i, vnode, \"removed\");\r\n    }\r\n  }\r\n  return textUpdated;\r\n};\r\n\r\nlet createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\r\n  let domNode, i, c, start = 0, type, found;\r\n  let vnodeSelector = vnode.vnodeSelector;\r\n  if(vnodeSelector === \"\") {\r\n    domNode = vnode.domNode = document.createTextNode(vnode.text);\r\n    if(insertBefore !== undefined) {\r\n      parentNode.insertBefore(domNode, insertBefore);\r\n    } else {\r\n      parentNode.appendChild(domNode);\r\n    }\r\n  } else {\r\n    for (i = 0; i <= vnodeSelector.length; ++i) {\r\n      c = vnodeSelector.charAt(i);\r\n      if (i === vnodeSelector.length || c === '.' || c === '#') {\r\n        type = vnodeSelector.charAt(start - 1);\r\n        found = vnodeSelector.slice(start, i);\r\n        if (type === \".\") {\r\n          domNode.classList.add(found);\r\n        } else if (type === \"#\") {\r\n          domNode.id = found;\r\n        } else {\r\n          if (found === \"svg\") {\r\n            projectionOptions = extend(projectionOptions, { namespace: \"http://www.w3.org/2000/svg\" });\r\n          }\r\n          if (projectionOptions.namespace !== undefined) {\r\n            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\r\n          } else {\r\n            domNode = vnode.domNode = document.createElement(found);\r\n          }\r\n          if (insertBefore !== undefined) {\r\n            parentNode.insertBefore(domNode, insertBefore);\r\n          } else {\r\n            parentNode.appendChild(domNode);\r\n          }\r\n        }\r\n        start = i + 1;\r\n      }\r\n    }\r\n    initPropertiesAndChildren(domNode, vnode, projectionOptions);\r\n  }\r\n};\r\n\r\nlet initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\r\n  addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\r\n  if(vnode.text) {\r\n    domNode.textContent = vnode.text;\r\n  }\r\n  setProperties(domNode, vnode.properties, projectionOptions);\r\n  if(vnode.properties && vnode.properties.afterCreate) {\r\n    vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n  }\r\n};\r\n\r\nlet updateDom = function (previous, vnode, projectionOptions) {\r\n  let domNode = previous.domNode;\r\n  if(!domNode) {\r\n    throw new Error(\"previous node was not rendered\");\r\n  }\r\n  let textUpdated = false;\r\n  if(previous === vnode) {\r\n    return textUpdated; // we assume that nothing has changed\r\n  }\r\n  let updated = false;\r\n  if(vnode.vnodeSelector === \"\") {\r\n    if(vnode.text !== previous.text) {\r\n      domNode.nodeValue = vnode.text;\r\n      textUpdated = true;\r\n    }\r\n  } else {\r\n    if(vnode.vnodeSelector.lastIndexOf(\"svg\", 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\r\n      projectionOptions = extend(projectionOptions, { namespace: \"http://www.w3.org/2000/svg\" });\r\n    }\r\n    if(previous.text !== vnode.text) {\r\n      updated = true;\r\n      if(vnode.text === undefined) {\r\n        domNode.removeChild(domNode.firstChild); // the only textnode presumably\r\n      } else {\r\n        domNode.textContent = vnode.text;\r\n      }\r\n    }\r\n    updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\r\n    updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\r\n    if(vnode.properties && vnode.properties.afterUpdate) {\r\n      vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n    }\r\n  }\r\n  if(updated && vnode.properties && vnode.properties.updateAnimation) {\r\n    vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\r\n  }\r\n  vnode.domNode = previous.domNode;\r\n  return textUpdated;\r\n};\r\n\r\n/**\r\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\r\n * @interface Projection\r\n */\r\nlet createProjection = function (vnode, projectionOptions) {\r\n  if(!vnode.vnodeSelector) {\r\n    throw new Error(\"Invalid vnode argument\");\r\n  }\r\n  return {\r\n    /**\r\n     * Updates the projection with the new virtual DOM tree.\r\n     * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant. \r\n     * @memberof Projection#\r\n     */\r\n    update: function (updatedVnode) {\r\n      if(vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\r\n        throw new Error(\"The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)\");\r\n      }\r\n      updateDom(vnode, updatedVnode, projectionOptions);\r\n      vnode = updatedVnode;\r\n    },\r\n    /**\r\n     * The DOM node that is used as the root of this {@link Projection}.\r\n     * @type {Element}\r\n     * @memberof Projection#\r\n     */\r\n    domNode: vnode.domNode\r\n  };\r\n};\r\n\r\n// Declaration of interfaces and callbacks, before the @exports maquette\r\n\r\n/**\r\n * A virtual representation of a DOM Node. Maquette assumes that {@link VNode} objects are never modified externally.\r\n * Instances of {@link VNode} can be created using {@link module:maquette.h}.\r\n * @interface VNode\r\n */\r\n\r\n/**\r\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs. \r\n * On subsequent calls the previous outcome is returned if the inputs are identical. \r\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\r\n * Instances of {@link CalculationCache} can be created using {@link module:maquette.createCache}.\r\n * @interface CalculationCache\r\n */\r\n\r\n/**\r\n * Keeps an array of result objects synchronized with an array of source objects.\r\n * Mapping provides a {@link Mapping#map} function that updates the {@link Mapping#results}. \r\n * The {@link Mapping#map} function can be called multiple times and the results will get created, removed and updated accordingly.\r\n * A {@link Mapping} can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\r\n * Instances of {@link Mapping} can be created using {@link module:maquette.createMapping}.\r\n * @interface Mapping\r\n */\r\n\r\n/**\r\n * Used to create and update the DOM.\r\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace} \r\n * to create the DOM.\r\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions \r\n * will be called again to update the DOM on the next animation-frame after:\r\n * \r\n *  - The {@link Projector#scheduleRender} function  was called\r\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\r\n * \r\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering. \r\n * It is possible to use `window.onerror` to handle these errors.\r\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\r\n * @interface Projector\r\n */\r\n\r\n/**\r\n * @callback enterAnimationCallback\r\n * @param {Element} element - Element that was just added to the DOM.\r\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n\r\n/**\r\n * @callback exitAnimationCallback\r\n * @param {Element} element - Element that ought to be removed from to the DOM.\r\n * @param {function(Element)} removeElement - Function that removes the element from the DOM. \r\n * This argument is supplied purely for convenience. \r\n * You may use this function to remove the element when the animation is done.\r\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method that rendered this {@link VNode} the previous time.\r\n */\r\n\r\n/**\r\n * @callback updateAnimationCallback\r\n * @param {Element} element - Element that was modified in the DOM.\r\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\r\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n  \r\n/**\r\n * @callback afterCreateCallback\r\n * @param {Element} element - The element that was added to the DOM.\r\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\r\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\r\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\r\n * @param {VNode[]} children - The children that were created.\r\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\r\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n\r\n/**\r\n * @callback afterUpdateCallback\r\n * @param {Element} element - The element that may have been updated in the DOM.\r\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\r\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\r\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\r\n * @param {VNode[]} children - The children for this node.\r\n */\r\n  \r\n/**\r\n * Contains simple low-level utility functions to manipulate the real DOM. The singleton instance is available under {@link module:maquette.dom}.\r\n * @interface MaquetteDom\r\n */\r\n  \r\n/**\r\n * The `h` method is used to create a virtual DOM node. \r\n * This function is largely inspired by the mercuryjs and mithril frameworks.\r\n * The `h` stands for (virtual) hyperscript.\r\n * \r\n * @param {string} selector - Contains the tagName, id and fixed css classnames in CSS selector format. \r\n * It is formatted as follows: `tagname.cssclass1.cssclass2#id`. \r\n * @param {Object} [properties] - An object literal containing properties that will be placed on the DOM node.\r\n * @param {function} properties.<b>*</b> - Properties with functions values like `onclick:handleClick` are registered as event handlers\r\n * @param {String} properties.<b>*</b> - Properties with string values, like `href:\"/\"` are used as attributes\r\n * @param {object} properties.<b>*</b> - All non-string values are put on the DOM node as properties\r\n * @param {Object} properties.key - Used to uniquely identify a DOM node among siblings. \r\n * A key is required when there are more children with the same selector and these children are added or removed dynamically.\r\n * @param {Object} properties.classes - An object literal like `{important:true}` which allows css classes, like `important` to be added and removed dynamically.\r\n * @param {Object} properties.styles - An object literal like `{height:\"100px\"}` which allows styles to be changed dynamically. All values must be strings.\r\n * @param {(string|enterAnimationCallback)} properties.enterAnimation - The animation to perform when this node is added to an already existing parent. \r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}. \r\n * @param {(string|exitAnimationCallback)} properties.exitAnimation - The animation to perform when this node is removed while its parent remains.\r\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}. \r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * @param {updateAnimationCallback} properties.updateAnimation - The animation to perform when the properties of this node change. \r\n * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * @param {afterCreateCallback} properties.afterCreate - Callback that is executed after this node is added to the DOM. Childnodes and properties have already been applied.\r\n * @param {afterUpdateCallback} properties.afterUpdate - Callback that is executed every time this node may have been updated. Childnodes and properties have already been updated. \r\n * @param {Object[]} [children] - An array of virtual DOM nodes to add as child nodes. \r\n * This array may contain nested arrays, `null` or `undefined` values.\r\n * Nested arrays are flattened, `null` and `undefined` will be skipped.\r\n * \r\n * @returns {VNode} A VNode object, used to render a real DOM later. \r\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\r\n */\r\nexport let h = function (selector /*, ...propertiesAndChildren */) {\r\n  let properties = arguments[1];\r\n  if (typeof selector !== \"string\") {\r\n    throw new Error();\r\n  }\r\n  let childIndex = 1;\r\n  if (properties && !properties.hasOwnProperty(\"vnodeSelector\") && !Array.isArray(properties) && typeof properties === \"object\") {\r\n    childIndex = 2;\r\n  } else {\r\n    // Optional properties argument was omitted\r\n    properties = undefined;\r\n  }\r\n  let text = undefined;\r\n  let children = undefined;\r\n  let argsLength = arguments.length;\r\n  // Recognize a common special case where there is only a single text node\r\n  if(argsLength === childIndex + 1) {\r\n    let onlyChild = arguments[childIndex];\r\n    if (typeof onlyChild === \"string\") {\r\n      text = onlyChild;\r\n    } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === \"string\") {\r\n      text = onlyChild[0];\r\n    }\r\n  } \r\n  if (text === undefined) {\r\n    children = [];\r\n    for (;childIndex<arguments.length;childIndex++) {\r\n      let child = arguments[childIndex];\r\n      if(child === null || child === undefined) {\r\n        continue;\r\n      } else if(Array.isArray(child)) {\r\n        appendChildren(selector, child, children);\r\n      } else if(child.hasOwnProperty(\"vnodeSelector\")) {\r\n        children.push(child);\r\n      } else {\r\n        children.push(toTextVNode(child));\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    /** \r\n     * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node. \r\n     * @memberof VNode# \r\n     */\r\n    vnodeSelector: selector,\r\n    /** \r\n     * Object containing attributes, properties, event handlers and more @see module:maquette.h \r\n     * @memberof VNode# \r\n     */\r\n    properties: properties,\r\n    /** \r\n     * Array of VNodes to be used as children. This array is already flattened. \r\n     * @memberof VNode# \r\n     */\r\n    children: children,\r\n    /**\r\n     * Used in a special case when a VNode only has one childnode which is a textnode. Only used in combination with children === undefined.\r\n     * @memberof VNode# \r\n     */\r\n    text: text,\r\n    /**\r\n     * Used by maquette to store the domNode that was produced from this {@link VNode}.\r\n     * @memberof VNode# \r\n     */\r\n    domNode: null\r\n  };\r\n};\r\n  \r\n/**\r\n * @type MaquetteDom\r\n */\r\nexport let dom = {\r\n  /**\r\n   * Creates a real DOM tree from a {@link VNode}. The {@link Projection} object returned will contain the resulting DOM Node under the {@link Projection#domNode} property. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} which contains the DOM Node that was created.\r\n   */\r\n  create: function (vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, document.createElement(\"div\"), undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Appends a new childnode to the DOM which is generated from a {@link VNode}. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} parentNode - The parent node for the new childNode.\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  append: function (parentNode, vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, parentNode, undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n  \r\n  /**\r\n   * Inserts a new DOM node which is generated from a {@link VNode}. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} beforeNode - The node that the DOM Node is inserted before.\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  insertBefore: function(beforeNode, vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Merges a new DOM node which is generated from a {@link VNode} with an existing DOM Node.\r\n   * This means that the virtual DOM and real DOM have one overlapping element. \r\n   * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.  \r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  merge: function (element, vnode, options) {\r\n    options = applyDefaultProjectionOptions(options);\r\n    vnode.domNode = element;\r\n    initPropertiesAndChildren(element, vnode, options);\r\n    return createProjection(vnode, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a {@link CalculationCache} object, useful for caching {@link VNode} trees. \r\n * In practice, caching of {@link VNode} trees is not needed, because achieving 60 frames per second is almost never a problem.\r\n * @returns {CalculationCache}\r\n */\r\nexport let createCache = function () {\r\n  let cachedInputs = undefined;\r\n  let cachedOutcome = undefined;\r\n  let result = {\r\n    /**\r\n     * Manually invalidates the cached outcome.\r\n     * @memberof CalculationCache#\r\n     */\r\n    invalidate: function () {\r\n      cachedOutcome = undefined;\r\n      cachedInputs = undefined;\r\n    },\r\n    /**\r\n     * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\r\n     * Otherwise, the calculation function is invoked and its result is cached and returned. \r\n     * Objects in the inputs array are compared using ===.\r\n     * @param {Object[]} inputs - Array of objects that are to be compared using === with the inputs from the previous invocation. \r\n     * These objects are assumed to be immutable primitive values.\r\n     * @param {function} calculation - Function that takes zero arguments and returns an object (A {@link VNode} assumably) that can be cached.\r\n     * @memberof CalculationCache#\r\n     */\r\n    result: function (inputs, calculation) {\r\n      if(cachedInputs) {\r\n        for(let i = 0; i < inputs.length; i++) {\r\n          if(cachedInputs[i] !== inputs[i]) {\r\n            cachedOutcome = undefined;\r\n          }\r\n        }\r\n      }\r\n      if(!cachedOutcome) {\r\n        cachedOutcome = calculation();\r\n        cachedInputs = inputs;\r\n      }\r\n      return cachedOutcome;\r\n    }\r\n  };\r\n  return result;\r\n};\r\n  \r\n/**\r\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\r\n * @param {function} getSourceKey - `function(source)` that must return a key to identify each source object. The result must eather be a string or a number.\r\n * @param {function} createResult - `function(source, index)` that must create a new result object from a given source. This function is identical argument of `Array.map`.\r\n * @param {function} updateResult - `function(source, target, index)` that updates a result to an updated source.\r\n * @returns {Mapping} \r\n */\r\nexport let createMapping = function(getSourceKey, createResult, updateResult /*, deleteTarget*/) {\r\n  let keys = [];\r\n  let results = [];\r\n  \r\n  return {\r\n    /**\r\n     * The array of results. These results will be synchronized with the latest array of sources that were provided using {@link Mapping#map}.\r\n     * @type {Object[]}\r\n     * @memberof Mapping#\r\n     */\r\n    results: results,\r\n    /**\r\n     * Maps a new array of sources and updates {@link Mapping#results}.\r\n     * @param {Object[]} newSources - The new array of sources.\r\n     * @memberof Mapping#\r\n     */\r\n    map: function(newSources) {\r\n      let newKeys = newSources.map(getSourceKey);\r\n      let oldTargets = results.slice();\r\n      let oldIndex = 0;\r\n      for (let i=0;i<newSources.length;i++) {\r\n        let source = newSources[i];\r\n        let sourceKey = newKeys[i];\r\n        if (sourceKey === keys[oldIndex]) {\r\n          results[i] = oldTargets[oldIndex];\r\n          updateResult(source, oldTargets[oldIndex], i);\r\n          oldIndex++;\r\n        } else {\r\n          let found = false;\r\n          for (let j = 1; j < keys.length; j++) {\r\n            let searchIndex = (oldIndex + j) % keys.length;\r\n            if (keys[searchIndex] === sourceKey) {\r\n              results[i] = oldTargets[searchIndex];\r\n              updateResult(newSources[i], oldTargets[searchIndex], i);\r\n              oldIndex = searchIndex + 1;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            results[i] = createResult(source, i);\r\n          }\r\n        }\r\n      }\r\n      results.length = newSources.length;\r\n      keys = newKeys;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a {@link Projector} instance using the provided projectionOptions.\r\n * @param {Object} [projectionOptions] - Options that influence how the DOM is rendered and updated.\r\n * @param {Object} projectionOptions.transitions - A transition strategy to invoke when \r\n * enterAnimation and exitAnimation properties are provided as strings.\r\n * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy. \r\n * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\r\n * @returns {Projector}\r\n */\r\nexport let createProjector = function (projectionOptions) {\r\n  projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n  projectionOptions.eventHandlerInterceptor = function (propertyName, functionPropertyArgument) {\r\n    return function () {\r\n      // intercept function calls (event handlers) to do a render afterwards.\r\n      projector.scheduleRender();\r\n      return functionPropertyArgument.apply(this, arguments);\r\n    };\r\n  };\r\n  let renderCompleted = true;\r\n  let scheduled;\r\n  let stopped = false;\r\n  let projections = [];\r\n  let renderFunctions = []; // matches the projections array\r\n\r\n  let doRender = function () {\r\n    scheduled = undefined;\r\n    if (!renderCompleted) {\r\n      return; // The last render threw an error, it should be logged in the browser console. \r\n    }\r\n    renderCompleted = false;\r\n    for(let i = 0; i < projections.length; i++) {\r\n      let updatedVnode = renderFunctions[i]();\r\n      projections[i].update(updatedVnode);\r\n    }\r\n    renderCompleted = true;\r\n  };\r\n\r\n  let projector = {\r\n    /**\r\n     * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\r\n     * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\r\n     * You need to call this method for instance when timeouts expire or AJAX responses arrive.\r\n     * @memberof Projector#\r\n     */\r\n    scheduleRender: function () {\r\n      if(!scheduled && !stopped) {\r\n        scheduled = requestAnimationFrame(doRender);\r\n      }\r\n    },\r\n    /**\r\n     * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\r\n     * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected as usual if it is no longer in scope.\r\n     * @memberof Projector#\r\n     */\r\n    stop: function () {\r\n      if(scheduled) {\r\n        cancelAnimationFrame(scheduled);\r\n        scheduled = undefined;\r\n      }\r\n      stopped = true;\r\n    },\r\n    \r\n    /**\r\n     * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\r\n     * @memberof Projector#\r\n     */\r\n    resume: function() {\r\n      stopped = false;\r\n      renderCompleted = true;\r\n      projector.scheduleRender();\r\n    },\r\n    \r\n    /**\r\n     * Scans the document for `<script>` tags with `type=\"text/hyperscript\"`.\r\n     * The content of these scripts are registered as `renderMaquette` functions.\r\n     * The result of evaluating these functions will be inserted into the DOM after the script.\r\n     * These scripts can make use of variables that come from the `parameters` parameter.\r\n     * @param {Element} rootNode - Element to start scanning at, example: `document.body`.\r\n     * @param {Object} parameters - Variables to expose to the scripts. format: `{var1:value1, var2: value2}`\r\n     * @memberof Projector#\r\n     */\r\n    evaluateHyperscript: function (rootNode, parameters) {\r\n      let nodes = rootNode.querySelectorAll(\"script[type='text/hyperscript']\");\r\n      let functionParameters = [\"maquette\", \"h\", \"enhancer\"];\r\n      let parameterValues = [{h, dom, createCache, createMapping, createProjector}, h, projector];\r\n      Object.keys(parameters).forEach(function (parameterName) {\r\n        functionParameters.push(parameterName);\r\n        parameterValues.push(parameters[parameterName]);\r\n      });\r\n      Array.prototype.forEach.call(nodes, function (node) {\r\n        let func = new Function(...functionParameters, \"return \" + node.textContent.trim());\r\n        let renderFunction = function () {\r\n          return func.apply(undefined, parameterValues);\r\n        };\r\n        projector.insertBefore(node, renderFunction);\r\n      });\r\n    },\r\n    \r\n    /**\r\n     * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} parentNode - The parent node for the new childNode.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    append: function (parentNode, renderMaquetteFunction) {\r\n      projections.push(dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} beforeNode - The node that the DOM Node is inserted before.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    insertBefore: function (beforeNode, renderMaquetteFunction) {\r\n      projections.push(dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\r\n     * This means that the virtual DOM and real DOM have one overlapping element. \r\n     * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.  \r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    merge: function (domNode, renderMaquetteFunction) {\r\n      projections.push(dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} domNode - The DOM node to replace.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    replace: function (domNode, renderMaquetteFunction) {\r\n      let vnode = renderMaquetteFunction();\r\n      createDom(vnode, domNode.parentNode, domNode, projectionOptions);\r\n      domNode.parentNode.removeChild(domNode);\r\n      projections.push(createProjection(vnode, projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    }\r\n  };\r\n  return projector;\r\n};\r\n"],"sourceRoot":"/source/"}