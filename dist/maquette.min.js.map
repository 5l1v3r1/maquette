{"version":3,"sources":["maquette.js","/source/maquette.ts"],"names":["root","factory","define","amd","exports","nodeName","maquette","this","emptyArray","extend","base","overrides","result","Object","keys","forEach","key","toTextVNode","data","vnodeSelector","properties","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","defaultProjectionOptions","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectionOptions","setProperties","propName","propValue","className","classList","add","styleValue","type","lastIndexOf","oldPropValue","evt","target","apply","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","addChildren","createDom","same","vnode1","vnode2","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","updateDom","findOldIndex","insertBefore","c","found","document","createTextNode","appendChild","charAt","slice","id","createElementNS","createElement","initPropertiesAndChildren","textContent","afterCreate","previous","updated","nodeValue","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","append","beforeNode","merge","element","options","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","j","searchIndex","createProjector","propertyName","functionPropertyArgument","projector","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","replace"],"mappings":"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","file":"maquette.min.js","sourcesContent":["(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data === null || data === undefined ? '' : data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0; i < insertions.length; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var defaultProjectionOptions = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectionOptions) {\n        return extend(defaultProjectionOptions, projectionOptions);\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        for (var propName in properties) {\n            var propValue = properties[propName];\n            if (propName === 'class' || propName === 'className' || propName === 'classList') {\n                throw new Error('Property ' + propName + ' is not supported, use \\'classes\\' instead.');\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                for (var className in propValue) {\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                for (var styleName in propValue) {\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        if (typeof styleValue !== 'string') {\n                            throw new Error('Style values may only be strings');\n                        }\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (eventHandlerInterceptor && propName.lastIndexOf('on', 0) === 0) {\n                        propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);\n                        // intercept eventhandlers\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                    }\n                    domNode[propName] = propValue;\n                } else if (type === 'string' && propName !== 'value') {\n                    domNode.setAttribute(propName, propValue);\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        for (var propName in properties) {\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'classes') {\n                var classList = domNode.classList;\n                for (var className in propValue) {\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                for (var styleName in propValue) {\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        if (typeof newStyleValue !== 'string') {\n                            throw new Error('Style values may only be strings');\n                        }\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string') {\n                        domNode.setAttribute(propName, propValue);\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            return vnode1.properties.key === vnode2.properties.key;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var key = childNode.properties ? childNode.properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: 'http://www.w3.org/2000/svg' });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n        }\n    };\n    var updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        if (!domNode) {\n            throw new Error('previous node was not rendered');\n        }\n        var textUpdated = false;\n        if (previous === vnode) {\n            return textUpdated;    // we assume that nothing has changed\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                domNode.nodeValue = vnode.text;\n                textUpdated = true;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: 'http://www.w3.org/2000/svg' });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    /**\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\n * @interface Projection\n */\n    var createProjection = function (vnode, projectionOptions) {\n        if (!vnode.vnodeSelector) {\n            throw new Error('Invalid vnode argument');\n        }\n        return {\n            /**\n         * Updates the projection with the new virtual DOM tree.\n         * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant.\n         * @memberof Projection#\n         */\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            /**\n         * The DOM node that is used as the root of this {@link Projection}.\n         * @type {Element}\n         * @memberof Projection#\n         */\n            domNode: vnode.domNode\n        };\n    };\n    // Declaration of interfaces and callbacks, before the @exports maquette\n    /**\n * A virtual representation of a DOM Node. Maquette assumes that {@link VNode} objects are never modified externally.\n * Instances of {@link VNode} can be created using {@link module:maquette.h}.\n * @interface VNode\n */\n    /**\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs.\n * On subsequent calls the previous outcome is returned if the inputs are identical.\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\n * Instances of {@link CalculationCache} can be created using {@link module:maquette.createCache}.\n * @interface CalculationCache\n */\n    /**\n * Keeps an array of result objects synchronized with an array of source objects.\n * Mapping provides a {@link Mapping#map} function that updates the {@link Mapping#results}.\n * The {@link Mapping#map} function can be called multiple times and the results will get created, removed and updated accordingly.\n * A {@link Mapping} can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\n * Instances of {@link Mapping} can be created using {@link module:maquette.createMapping}.\n * @interface Mapping\n */\n    /**\n * Used to create and update the DOM.\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace}\n * to create the DOM.\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions\n * will be called again to update the DOM on the next animation-frame after:\n *\n *  - The {@link Projector#scheduleRender} function  was called\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\n *\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\n * @interface Projector\n */\n    /**\n * @callback enterAnimationCallback\n * @param {Element} element - Element that was just added to the DOM.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback exitAnimationCallback\n * @param {Element} element - Element that ought to be removed from to the DOM.\n * @param {function(Element)} removeElement - Function that removes the element from the DOM.\n * This argument is supplied purely for convenience.\n * You may use this function to remove the element when the animation is done.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method that rendered this {@link VNode} the previous time.\n */\n    /**\n * @callback updateAnimationCallback\n * @param {Element} element - Element that was modified in the DOM.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback afterCreateCallback\n * @param {Element} element - The element that was added to the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children that were created.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback afterUpdateCallback\n * @param {Element} element - The element that may have been updated in the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children for this node.\n */\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM. The singleton instance is available under {@link module:maquette.dom}.\n * @interface MaquetteDom\n */\n    /**\n * The `h` method is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * @param {string} selector - Contains the tagName, id and fixed css classnames in CSS selector format.\n * It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n * @param {Object} [properties] - An object literal containing properties that will be placed on the DOM node.\n * @param {function} properties.<b>*</b> - Properties with functions values like `onclick:handleClick` are registered as event handlers\n * @param {String} properties.<b>*</b> - Properties with string values, like `href:\"/\"` are used as attributes\n * @param {object} properties.<b>*</b> - All non-string values are put on the DOM node as properties\n * @param {Object} properties.key - Used to uniquely identify a DOM node among siblings.\n * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n * @param {Object} properties.classes - An object literal like `{important:true}` which allows css classes, like `important` to be added and removed dynamically.\n * @param {Object} properties.styles - An object literal like `{height:\"100px\"}` which allows styles to be changed dynamically. All values must be strings.\n * @param {(string|enterAnimationCallback)} properties.enterAnimation - The animation to perform when this node is added to an already existing parent.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * @param {(string|exitAnimationCallback)} properties.exitAnimation - The animation to perform when this node is removed while its parent remains.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {updateAnimationCallback} properties.updateAnimation - The animation to perform when the properties of this node change.\n * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {afterCreateCallback} properties.afterCreate - Callback that is executed after this node is added to the DOM. Childnodes and properties have already been applied.\n * @param {afterUpdateCallback} properties.afterUpdate - Callback that is executed every time this node may have been updated. Childnodes and properties have already been updated.\n * @param {Object[]} [children] - An array of virtual DOM nodes to add as child nodes.\n * This array may contain nested arrays, `null` or `undefined` values.\n * Nested arrays are flattened, `null` and `undefined` will be skipped.\n *\n * @returns {VNode} A VNode object, used to render a real DOM later.\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\n */\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < arguments.length; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            /**\n         * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node.\n         * @memberof VNode#\n         */\n            vnodeSelector: selector,\n            /**\n         * Object containing attributes, properties, event handlers and more @see module:maquette.h\n         * @memberof VNode#\n         */\n            properties: properties,\n            /**\n         * Array of VNodes to be used as children. This array is already flattened.\n         * @memberof VNode#\n         */\n            children: children,\n            /**\n         * Used in a special case when a VNode only has one childnode which is a textnode. Only used in combination with children === undefined.\n         * @memberof VNode#\n         */\n            text: text,\n            /**\n         * Used by maquette to store the domNode that was produced from this {@link VNode}.\n         * @memberof VNode#\n         */\n            domNode: null\n        };\n    };\n    /**\n * @type MaquetteDom\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from a {@link VNode}. The {@link Projection} object returned will contain the resulting DOM Node under the {@link Projection#domNode} property.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} which contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a {@link VNode}.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} parentNode - The parent node for the new childNode.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a {@link VNode}.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a {@link VNode} with an existing DOM Node.\n     * This means that the virtual DOM and real DOM have one overlapping element.\n     * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        merge: function (element, vnode, options) {\n            options = applyDefaultProjectionOptions(options);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, options);\n            return createProjection(vnode, options);\n        }\n    };\n    /**\n * Creates a {@link CalculationCache} object, useful for caching {@link VNode} trees.\n * In practice, caching of {@link VNode} trees is not needed, because achieving 60 frames per second is almost never a problem.\n * @returns {CalculationCache}\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            /**\n         * Manually invalidates the cached outcome.\n         * @memberof CalculationCache#\n         */\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            /**\n         * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\n         * Otherwise, the calculation function is invoked and its result is cached and returned.\n         * Objects in the inputs array are compared using ===.\n         * @param {Object[]} inputs - Array of objects that are to be compared using === with the inputs from the previous invocation.\n         * These objects are assumed to be immutable primitive values.\n         * @param {function} calculation - Function that takes zero arguments and returns an object (A {@link VNode} assumably) that can be cached.\n         * @memberof CalculationCache#\n         */\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * @param {function} getSourceKey - `function(source)` that must return a key to identify each source object. The result must eather be a string or a number.\n * @param {function} createResult - `function(source, index)` that must create a new result object from a given source. This function is identical argument of `Array.map`.\n * @param {function} updateResult - `function(source, target, index)` that updates a result to an updated source.\n * @returns {Mapping}\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            /**\n         * The array of results. These results will be synchronized with the latest array of sources that were provided using {@link Mapping#map}.\n         * @type {Object[]}\n         * @memberof Mapping#\n         */\n            results: results,\n            /**\n         * Maps a new array of sources and updates {@link Mapping#results}.\n         * @param {Object[]} newSources - The new array of sources.\n         * @memberof Mapping#\n         */\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a {@link Projector} instance using the provided projectionOptions.\n * @param {Object} [projectionOptions] - Options that influence how the DOM is rendered and updated.\n * @param {Object} projectionOptions.transitions - A transition strategy to invoke when\n * enterAnimation and exitAnimation properties are provided as strings.\n * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\n * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\n * @returns {Projector}\n */\n    exports.createProjector = function (projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, functionPropertyArgument) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return functionPropertyArgument.apply(this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console. \n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        var projector = {\n            /**\n         * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\n         * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\n         * You need to call this method for instance when timeouts expire or AJAX responses arrive.\n         * @memberof Projector#\n         */\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            /**\n         * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\n         * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected as usual if it is no longer in scope.\n         * @memberof Projector#\n         */\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            /**\n         * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\n         * @memberof Projector#\n         */\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            /**\n         * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} parentNode - The parent node for the new childNode.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\n         * This means that the virtual DOM and real DOM have one overlapping element.\n         * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} domNode - The DOM node to replace.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            }\n        };\n        return projector;\n    };\n}));","// Utilities\r\n\r\nlet emptyArray = [];\r\n\r\nlet extend = function (base, overrides) {\r\n  let result = {};\r\n  Object.keys(base).forEach(function (key) {\r\n    result[key] = base[key];\r\n  });\r\n  if(overrides) {\r\n    Object.keys(overrides).forEach(function (key) {\r\n      result[key] = overrides[key];\r\n    });\r\n  }\r\n  return result;\r\n};\r\n\r\n// Hyperscript helper functions\r\n\r\nlet toTextVNode = function (data) {\r\n  return {\r\n    vnodeSelector: \"\",\r\n    properties: undefined,\r\n    children: undefined,\r\n    text: (data === null || data === undefined) ? \"\" : data.toString(),\r\n    domNode: null\r\n  };\r\n};\r\n\r\nlet appendChildren = function (parentSelector, insertions, main) {\r\n  for(let i = 0; i < insertions.length; i++) {\r\n    let item = insertions[i];\r\n    if(Array.isArray(item)) {\r\n      appendChildren(parentSelector, item, main);\r\n    } else {\r\n      if(item !== null && item !== undefined) {\r\n        if(!item.hasOwnProperty(\"vnodeSelector\")) {\r\n          item = toTextVNode(item);\r\n        }\r\n        main.push(item);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Render helper functions\r\n\r\nlet missingTransition = function() {\r\n  throw new Error(\"Provide a transitions object to the projectionOptions to do animations\");\r\n};\r\n\r\nlet defaultProjectionOptions = {\r\n  namespace: undefined,\r\n  eventHandlerInterceptor: undefined,\r\n  styleApplyer: function(domNode, styleName, value) {\r\n    // Provides a hook to add vendor prefixes for browsers that still need it.\r\n    domNode.style[styleName] = value;\r\n  },\r\n  transitions: {\r\n    enter: missingTransition,\r\n    exit: missingTransition\r\n  }\r\n};\r\n\r\nlet applyDefaultProjectionOptions = function (projectionOptions) {\r\n  return extend(defaultProjectionOptions, projectionOptions);\r\n};\r\n\r\nlet setProperties = function (domNode, properties, projectionOptions) {\r\n  if(!properties) {\r\n    return;\r\n  }\r\n  let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n  for(let propName in properties) {\r\n    var propValue = properties[propName];\r\n    if(propName === \"class\" || propName === \"className\" || propName === \"classList\") {\r\n      throw new Error(\"Property \" + propName + \" is not supported, use 'classes' instead.\");\r\n    } else if(propName === \"classes\") {\r\n      // object with string keys and boolean values\r\n      for(let className in propValue) {\r\n        if(propValue[className]) {\r\n          domNode.classList.add(className);\r\n        }\r\n      }\r\n    } else if(propName === \"styles\") {\r\n      // object with string keys and string (!) values\r\n      for(let styleName in propValue) {\r\n        let styleValue = propValue[styleName];\r\n        if(styleValue) {\r\n          if(typeof styleValue !== \"string\") {\r\n            throw new Error(\"Style values may only be strings\");\r\n          }\r\n          projectionOptions.styleApplyer(domNode, styleName, styleValue);\r\n        }\r\n      }\r\n    } else if(propName === \"key\") {\r\n      continue;\r\n    } else if(propValue === null || propValue === undefined) {\r\n      continue;\r\n    } else {\r\n      let type = typeof propValue;\r\n      if(type === \"function\") {\r\n        if(eventHandlerInterceptor && (propName.lastIndexOf(\"on\", 0) === 0)) { // lastIndexOf(,0)===0 -> startsWith\r\n          propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\r\n          if(propName === \"oninput\") {\r\n            (function () {\r\n              // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\r\n              let oldPropValue = propValue;\r\n              propValue = function (evt) {\r\n                evt.target[\"oninput-value\"] = evt.target.value;\r\n                oldPropValue.apply(this, [evt]);\r\n              };\r\n            }());\r\n          }\r\n        }\r\n        domNode[propName] = propValue;\r\n      } else if(type === \"string\" && propName !== \"value\") {\r\n        domNode.setAttribute(propName, propValue);\r\n      } else {\r\n        domNode[propName] = propValue;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\r\n  if(!properties) {\r\n    return;\r\n  }\r\n  let propertiesUpdated = false;\r\n  for(let propName in properties) {\r\n    // assuming that properties will be nullified instead of missing is by design\r\n    let propValue = properties[propName];\r\n    let previousValue = previousProperties[propName];\r\n    if(propName === \"classes\") {\r\n      let classList = domNode.classList;\r\n      for(let className in propValue) {\r\n        let on = !!propValue[className];\r\n        let previousOn = !!previousValue[className];\r\n        if(on === previousOn) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if(on) {\r\n          classList.add(className);\r\n        } else {\r\n          classList.remove(className);\r\n        }\r\n      }\r\n    } else if(propName === \"styles\") {\r\n      for(let styleName in propValue) {\r\n        let newStyleValue = propValue[styleName];\r\n        let oldStyleValue = previousValue[styleName];\r\n        if(newStyleValue === oldStyleValue) {\r\n          continue;\r\n        }\r\n        propertiesUpdated = true;\r\n        if(newStyleValue) {\r\n          if(typeof newStyleValue !== \"string\") {\r\n            throw new Error(\"Style values may only be strings\");\r\n          }\r\n          projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\r\n        } else {\r\n          projectionOptions.styleApplyer(domNode, styleName, \"\");\r\n        }\r\n      }\r\n    } else {\r\n      if(!propValue && typeof previousValue === \"string\") {\r\n        propValue = \"\";\r\n      }\r\n      if(propName === \"value\") { // value can be manipulated by the user directly and using event.preventDefault() is not an option\r\n        if(domNode[propName] !== propValue && domNode[\"oninput-value\"] !== propValue) {\r\n          domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\r\n          domNode[\"oninput-value\"] = undefined;\r\n        } // else do not update the domNode, otherwise the cursor position would be changed\r\n        if(propValue !== previousValue) {\r\n          propertiesUpdated = true;\r\n        }\r\n      } else if(propValue !== previousValue) {\r\n        let type = typeof propValue;\r\n        if(type === \"function\") {\r\n          throw new Error(\"Functions may not be updated on subsequent renders (property: \" + propName +\r\n            \"). Hint: declare event handler functions outside the render() function.\");\r\n        }\r\n        if(type === \"string\") {\r\n          domNode.setAttribute(propName, propValue);\r\n        } else {\r\n          if(domNode[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\r\n            domNode[propName] = propValue;\r\n          }\r\n        }\r\n        propertiesUpdated = true;\r\n      }\r\n    }\r\n  }\r\n  return propertiesUpdated;\r\n};\r\n\r\nlet addChildren = function (domNode, children, projectionOptions) {\r\n  if(!children) {\r\n    return;\r\n  }\r\n  for(let i = 0; i < children.length; i++) {\r\n    createDom(children[i], domNode, undefined, projectionOptions);\r\n  }\r\n};\r\n\r\nlet same = function (vnode1, vnode2) {\r\n  if(vnode1.vnodeSelector !== vnode2.vnodeSelector) {\r\n    return false;\r\n  }\r\n  if(vnode1.properties && vnode2.properties) {\r\n    return vnode1.properties.key === vnode2.properties.key;\r\n  }\r\n  return !vnode1.properties && !vnode2.properties;\r\n};\r\n\r\nlet findIndexOfChild = function (children, sameAs, start) {\r\n  if(sameAs.vnodeSelector !== \"\") {\r\n    // Never scan for text-nodes\r\n    for(let i = start; i < children.length; i++) {\r\n      if(same(children[i], sameAs)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nlet nodeAdded = function (vNode, transitions) {\r\n  if(vNode.properties) {\r\n    let enterAnimation = vNode.properties.enterAnimation;\r\n    if(enterAnimation) {\r\n      if(typeof enterAnimation === \"function\") {\r\n        enterAnimation(vNode.domNode, vNode.properties);\r\n      } else {\r\n        transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet nodeToRemove = function (vNode, transitions) {\r\n  let domNode = vNode.domNode;\r\n  if(vNode.properties) {\r\n    let exitAnimation = vNode.properties.exitAnimation;\r\n    if(exitAnimation) {\r\n      domNode.style.pointerEvents = \"none\";\r\n      let removeDomNode = function () {\r\n        if(domNode.parentNode) {\r\n          domNode.parentNode.removeChild(domNode);\r\n        }\r\n      };\r\n      if(typeof exitAnimation === \"function\") {\r\n        exitAnimation(domNode, removeDomNode, vNode.properties);\r\n        return;\r\n      } else {\r\n        transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if(domNode.parentNode) {\r\n    domNode.parentNode.removeChild(domNode);\r\n  }\r\n};\r\n\r\nlet checkDistinguishable = function(childNodes, indexToCheck, parentVNode, operation) {\r\n  let childNode = childNodes[indexToCheck];\r\n  if (childNode.vnodeSelector === \"\") {\r\n    return; // Text nodes need not be distinguishable\r\n  }\r\n  let key = childNode.properties ? childNode.properties.key : undefined;\r\n  if (!key) { // A key is just assumed to be unique\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n      if (i !== indexToCheck) {\r\n        let node = childNodes[i];\r\n        if (same(node, childNode)) {\r\n          if (operation === \"added\") {\r\n            throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" +\r\n              \"added, but there is now more than one. You must add unique key properties to make them distinguishable.\");\r\n          } else {\r\n            throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" +\r\n              \"removed, but there were more than one. You must add unique key properties to make them distinguishable.\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nlet updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\r\n  if(oldChildren === newChildren) {\r\n    return false;\r\n  }\r\n  oldChildren = oldChildren || emptyArray;\r\n  newChildren = newChildren || emptyArray;\r\n  let oldChildrenLength = oldChildren.length;\r\n  let newChildrenLength = newChildren.length;\r\n  let transitions = projectionOptions.transitions;\r\n\r\n  let oldIndex = 0;\r\n  let newIndex = 0;\r\n  let i;\r\n  let textUpdated = false;\r\n  while(newIndex < newChildrenLength) {\r\n    let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\r\n    let newChild = newChildren[newIndex];\r\n    if(oldChild !== undefined && same(oldChild, newChild)) {\r\n      textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\r\n      oldIndex++;\r\n    } else {\r\n      let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\r\n      if(findOldIndex >= 0) {\r\n        // Remove preceding missing children\r\n        for(i = oldIndex; i < findOldIndex; i++) {\r\n          nodeToRemove(oldChildren[i], transitions);\r\n          checkDistinguishable(oldChildren, i, vnode, \"removed\");\r\n        }\r\n        textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\r\n        oldIndex = findOldIndex + 1;\r\n      } else {\r\n        // New child\r\n        createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\r\n        nodeAdded(newChild, transitions);\r\n        checkDistinguishable(newChildren, newIndex, vnode, \"added\");\r\n      }\r\n    }\r\n    newIndex++;\r\n  }\r\n  if(oldChildrenLength > oldIndex) {\r\n    // Remove child fragments\r\n    for(i = oldIndex; i < oldChildrenLength; i++) {\r\n      nodeToRemove(oldChildren[i], transitions);\r\n      checkDistinguishable(oldChildren, i, vnode, \"removed\");\r\n    }\r\n  }\r\n  return textUpdated;\r\n};\r\n\r\nvar createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\r\n  let domNode, i, c, start = 0, type, found;\r\n  let vnodeSelector = vnode.vnodeSelector;\r\n  if(vnodeSelector === \"\") {\r\n    domNode = vnode.domNode = document.createTextNode(vnode.text);\r\n    if(insertBefore !== undefined) {\r\n      parentNode.insertBefore(domNode, insertBefore);\r\n    } else {\r\n      parentNode.appendChild(domNode);\r\n    }\r\n  } else {\r\n    for (i = 0; i <= vnodeSelector.length; ++i) {\r\n      c = vnodeSelector.charAt(i);\r\n      if (i === vnodeSelector.length || c === '.' || c === '#') {\r\n        type = vnodeSelector.charAt(start - 1);\r\n        found = vnodeSelector.slice(start, i);\r\n        if (type === \".\") {\r\n          domNode.classList.add(found);\r\n        } else if (type === \"#\") {\r\n          domNode.id = found;\r\n        } else {\r\n          if (found === \"svg\") {\r\n            projectionOptions = extend(projectionOptions, { namespace: \"http://www.w3.org/2000/svg\" });\r\n          }\r\n          if (projectionOptions.namespace !== undefined) {\r\n            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\r\n          } else {\r\n            domNode = vnode.domNode = document.createElement(found);\r\n          }\r\n          if (insertBefore !== undefined) {\r\n            parentNode.insertBefore(domNode, insertBefore);\r\n          } else {\r\n            parentNode.appendChild(domNode);\r\n          }\r\n        }\r\n        start = i + 1;\r\n      }\r\n    }\r\n    initPropertiesAndChildren(domNode, vnode, projectionOptions);\r\n  }\r\n};\r\n\r\nvar initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\r\n  addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\r\n  if(vnode.text) {\r\n    domNode.textContent = vnode.text;\r\n  }\r\n  setProperties(domNode, vnode.properties, projectionOptions);\r\n  if(vnode.properties && vnode.properties.afterCreate) {\r\n    vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n  }\r\n};\r\n\r\nvar updateDom = function (previous, vnode, projectionOptions) {\r\n  let domNode = previous.domNode;\r\n  if(!domNode) {\r\n    throw new Error(\"previous node was not rendered\");\r\n  }\r\n  let textUpdated = false;\r\n  if(previous === vnode) {\r\n    return textUpdated; // we assume that nothing has changed\r\n  }\r\n  let updated = false;\r\n  if(vnode.vnodeSelector === \"\") {\r\n    if(vnode.text !== previous.text) {\r\n      domNode.nodeValue = vnode.text;\r\n      textUpdated = true;\r\n    }\r\n  } else {\r\n    if(vnode.vnodeSelector.lastIndexOf(\"svg\", 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\r\n      projectionOptions = extend(projectionOptions, { namespace: \"http://www.w3.org/2000/svg\" });\r\n    }\r\n    if(previous.text !== vnode.text) {\r\n      updated = true;\r\n      if(vnode.text === undefined) {\r\n        domNode.removeChild(domNode.firstChild); // the only textnode presumably\r\n      } else {\r\n        domNode.textContent = vnode.text;\r\n      }\r\n    }\r\n    updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\r\n    updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\r\n    if(vnode.properties && vnode.properties.afterUpdate) {\r\n      vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\r\n    }\r\n  }\r\n  if(updated && vnode.properties && vnode.properties.updateAnimation) {\r\n    vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\r\n  }\r\n  vnode.domNode = previous.domNode;\r\n  return textUpdated;\r\n};\r\n\r\n/**\r\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\r\n * @interface Projection\r\n */\r\nlet createProjection = function (vnode, projectionOptions) {\r\n  if(!vnode.vnodeSelector) {\r\n    throw new Error(\"Invalid vnode argument\");\r\n  }\r\n  return {\r\n    /**\r\n     * Updates the projection with the new virtual DOM tree.\r\n     * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant. \r\n     * @memberof Projection#\r\n     */\r\n    update: function (updatedVnode) {\r\n      if(vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\r\n        throw new Error(\"The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)\");\r\n      }\r\n      updateDom(vnode, updatedVnode, projectionOptions);\r\n      vnode = updatedVnode;\r\n    },\r\n    /**\r\n     * The DOM node that is used as the root of this {@link Projection}.\r\n     * @type {Element}\r\n     * @memberof Projection#\r\n     */\r\n    domNode: vnode.domNode\r\n  };\r\n};\r\n\r\n// Declaration of interfaces and callbacks, before the @exports maquette\r\n\r\n/**\r\n * A virtual representation of a DOM Node. Maquette assumes that {@link VNode} objects are never modified externally.\r\n * Instances of {@link VNode} can be created using {@link module:maquette.h}.\r\n * @interface VNode\r\n */\r\n\r\n/**\r\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs. \r\n * On subsequent calls the previous outcome is returned if the inputs are identical. \r\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\r\n * Instances of {@link CalculationCache} can be created using {@link module:maquette.createCache}.\r\n * @interface CalculationCache\r\n */\r\n\r\n/**\r\n * Keeps an array of result objects synchronized with an array of source objects.\r\n * Mapping provides a {@link Mapping#map} function that updates the {@link Mapping#results}. \r\n * The {@link Mapping#map} function can be called multiple times and the results will get created, removed and updated accordingly.\r\n * A {@link Mapping} can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\r\n * Instances of {@link Mapping} can be created using {@link module:maquette.createMapping}.\r\n * @interface Mapping\r\n */\r\n\r\n/**\r\n * Used to create and update the DOM.\r\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace} \r\n * to create the DOM.\r\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions \r\n * will be called again to update the DOM on the next animation-frame after:\r\n * \r\n *  - The {@link Projector#scheduleRender} function  was called\r\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\r\n * \r\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering. \r\n * It is possible to use `window.onerror` to handle these errors.\r\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\r\n * @interface Projector\r\n */\r\n\r\n/**\r\n * @callback enterAnimationCallback\r\n * @param {Element} element - Element that was just added to the DOM.\r\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n\r\n/**\r\n * @callback exitAnimationCallback\r\n * @param {Element} element - Element that ought to be removed from to the DOM.\r\n * @param {function(Element)} removeElement - Function that removes the element from the DOM. \r\n * This argument is supplied purely for convenience. \r\n * You may use this function to remove the element when the animation is done.\r\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method that rendered this {@link VNode} the previous time.\r\n */\r\n\r\n/**\r\n * @callback updateAnimationCallback\r\n * @param {Element} element - Element that was modified in the DOM.\r\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\r\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n  \r\n/**\r\n * @callback afterCreateCallback\r\n * @param {Element} element - The element that was added to the DOM.\r\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\r\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\r\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\r\n * @param {VNode[]} children - The children that were created.\r\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\r\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\r\n */\r\n\r\n/**\r\n * @callback afterUpdateCallback\r\n * @param {Element} element - The element that may have been updated in the DOM.\r\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\r\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\r\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\r\n * @param {VNode[]} children - The children for this node.\r\n */\r\n  \r\n/**\r\n * Contains simple low-level utility functions to manipulate the real DOM. The singleton instance is available under {@link module:maquette.dom}.\r\n * @interface MaquetteDom\r\n */\r\n  \r\n/**\r\n * The `h` method is used to create a virtual DOM node. \r\n * This function is largely inspired by the mercuryjs and mithril frameworks.\r\n * The `h` stands for (virtual) hyperscript.\r\n * \r\n * @param {string} selector - Contains the tagName, id and fixed css classnames in CSS selector format. \r\n * It is formatted as follows: `tagname.cssclass1.cssclass2#id`. \r\n * @param {Object} [properties] - An object literal containing properties that will be placed on the DOM node.\r\n * @param {function} properties.<b>*</b> - Properties with functions values like `onclick:handleClick` are registered as event handlers\r\n * @param {String} properties.<b>*</b> - Properties with string values, like `href:\"/\"` are used as attributes\r\n * @param {object} properties.<b>*</b> - All non-string values are put on the DOM node as properties\r\n * @param {Object} properties.key - Used to uniquely identify a DOM node among siblings. \r\n * A key is required when there are more children with the same selector and these children are added or removed dynamically.\r\n * @param {Object} properties.classes - An object literal like `{important:true}` which allows css classes, like `important` to be added and removed dynamically.\r\n * @param {Object} properties.styles - An object literal like `{height:\"100px\"}` which allows styles to be changed dynamically. All values must be strings.\r\n * @param {(string|enterAnimationCallback)} properties.enterAnimation - The animation to perform when this node is added to an already existing parent. \r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}. \r\n * @param {(string|exitAnimationCallback)} properties.exitAnimation - The animation to perform when this node is removed while its parent remains.\r\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}. \r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * @param {updateAnimationCallback} properties.updateAnimation - The animation to perform when the properties of this node change. \r\n * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\r\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\r\n * @param {afterCreateCallback} properties.afterCreate - Callback that is executed after this node is added to the DOM. Childnodes and properties have already been applied.\r\n * @param {afterUpdateCallback} properties.afterUpdate - Callback that is executed every time this node may have been updated. Childnodes and properties have already been updated. \r\n * @param {Object[]} [children] - An array of virtual DOM nodes to add as child nodes. \r\n * This array may contain nested arrays, `null` or `undefined` values.\r\n * Nested arrays are flattened, `null` and `undefined` will be skipped.\r\n * \r\n * @returns {VNode} A VNode object, used to render a real DOM later. \r\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\r\n */\r\nexport let h = function (selector /*, ...propertiesAndChildren */) {\r\n  let properties = arguments[1];\r\n  if (typeof selector !== \"string\") {\r\n    throw new Error();\r\n  }\r\n  let childIndex = 1;\r\n  if (properties && !properties.hasOwnProperty(\"vnodeSelector\") && !Array.isArray(properties) && typeof properties === \"object\") {\r\n    childIndex = 2;\r\n  } else {\r\n    // Optional properties argument was omitted\r\n    properties = undefined;\r\n  }\r\n  let text = undefined;\r\n  let children = undefined;\r\n  let argsLength = arguments.length;\r\n  // Recognize a common special case where there is only a single text node\r\n  if(argsLength === childIndex + 1) {\r\n    let onlyChild = arguments[childIndex];\r\n    if (typeof onlyChild === \"string\") {\r\n      text = onlyChild;\r\n    } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === \"string\") {\r\n      text = onlyChild[0];\r\n    }\r\n  } \r\n  if (text === undefined) {\r\n    children = [];\r\n    for (;childIndex<arguments.length;childIndex++) {\r\n      let child = arguments[childIndex];\r\n      if(child === null || child === undefined) {\r\n        continue;\r\n      } else if(Array.isArray(child)) {\r\n        appendChildren(selector, child, children);\r\n      } else if(child.hasOwnProperty(\"vnodeSelector\")) {\r\n        children.push(child);\r\n      } else {\r\n        children.push(toTextVNode(child));\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    /** \r\n     * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node. \r\n     * @memberof VNode# \r\n     */\r\n    vnodeSelector: selector,\r\n    /** \r\n     * Object containing attributes, properties, event handlers and more @see module:maquette.h \r\n     * @memberof VNode# \r\n     */\r\n    properties: properties,\r\n    /** \r\n     * Array of VNodes to be used as children. This array is already flattened. \r\n     * @memberof VNode# \r\n     */\r\n    children: children,\r\n    /**\r\n     * Used in a special case when a VNode only has one childnode which is a textnode. Only used in combination with children === undefined.\r\n     * @memberof VNode# \r\n     */\r\n    text: text,\r\n    /**\r\n     * Used by maquette to store the domNode that was produced from this {@link VNode}.\r\n     * @memberof VNode# \r\n     */\r\n    domNode: null\r\n  };\r\n};\r\n  \r\n/**\r\n * @type MaquetteDom\r\n */\r\nexport let dom = {\r\n  /**\r\n   * Creates a real DOM tree from a {@link VNode}. The {@link Projection} object returned will contain the resulting DOM Node under the {@link Projection#domNode} property. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} which contains the DOM Node that was created.\r\n   */\r\n  create: function (vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, document.createElement(\"div\"), undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Appends a new childnode to the DOM which is generated from a {@link VNode}. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} parentNode - The parent node for the new childNode.\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  append: function (parentNode, vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, parentNode, undefined, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n  \r\n  /**\r\n   * Inserts a new DOM node which is generated from a {@link VNode}. \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} beforeNode - The node that the DOM Node is inserted before.\r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  insertBefore: function(beforeNode, vnode, projectionOptions) {\r\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n    createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\r\n    return createProjection(vnode, projectionOptions);\r\n  },\r\n\r\n  /**\r\n   * Merges a new DOM node which is generated from a {@link VNode} with an existing DOM Node.\r\n   * This means that the virtual DOM and real DOM have one overlapping element. \r\n   * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided \r\n   * This is a low-level method. Users wil typically use a {@link Projector} instead. \r\n   * @memberof MaquetteDom#\r\n   * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.  \r\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects may only be rendered once.\r\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}. \r\n   * @returns {Projection} The {@link Projection} that was created.\r\n   */\r\n  merge: function (element, vnode, options) {\r\n    options = applyDefaultProjectionOptions(options);\r\n    vnode.domNode = element;\r\n    initPropertiesAndChildren(element, vnode, options);\r\n    return createProjection(vnode, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a {@link CalculationCache} object, useful for caching {@link VNode} trees. \r\n * In practice, caching of {@link VNode} trees is not needed, because achieving 60 frames per second is almost never a problem.\r\n * @returns {CalculationCache}\r\n */\r\nexport let createCache = function () {\r\n  let cachedInputs = undefined;\r\n  let cachedOutcome = undefined;\r\n  let result = {\r\n    /**\r\n     * Manually invalidates the cached outcome.\r\n     * @memberof CalculationCache#\r\n     */\r\n    invalidate: function () {\r\n      cachedOutcome = undefined;\r\n      cachedInputs = undefined;\r\n    },\r\n    /**\r\n     * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\r\n     * Otherwise, the calculation function is invoked and its result is cached and returned. \r\n     * Objects in the inputs array are compared using ===.\r\n     * @param {Object[]} inputs - Array of objects that are to be compared using === with the inputs from the previous invocation. \r\n     * These objects are assumed to be immutable primitive values.\r\n     * @param {function} calculation - Function that takes zero arguments and returns an object (A {@link VNode} assumably) that can be cached.\r\n     * @memberof CalculationCache#\r\n     */\r\n    result: function (inputs, calculation) {\r\n      if(cachedInputs) {\r\n        for(let i = 0; i < inputs.length; i++) {\r\n          if(cachedInputs[i] !== inputs[i]) {\r\n            cachedOutcome = undefined;\r\n          }\r\n        }\r\n      }\r\n      if(!cachedOutcome) {\r\n        cachedOutcome = calculation();\r\n        cachedInputs = inputs;\r\n      }\r\n      return cachedOutcome;\r\n    }\r\n  };\r\n  return result;\r\n};\r\n  \r\n/**\r\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\r\n * @param {function} getSourceKey - `function(source)` that must return a key to identify each source object. The result must eather be a string or a number.\r\n * @param {function} createResult - `function(source, index)` that must create a new result object from a given source. This function is identical argument of `Array.map`.\r\n * @param {function} updateResult - `function(source, target, index)` that updates a result to an updated source.\r\n * @returns {Mapping} \r\n */\r\nexport let createMapping = function(getSourceKey, createResult, updateResult /*, deleteTarget*/) {\r\n  let keys = [];\r\n  let results = [];\r\n  \r\n  return {\r\n    /**\r\n     * The array of results. These results will be synchronized with the latest array of sources that were provided using {@link Mapping#map}.\r\n     * @type {Object[]}\r\n     * @memberof Mapping#\r\n     */\r\n    results: results,\r\n    /**\r\n     * Maps a new array of sources and updates {@link Mapping#results}.\r\n     * @param {Object[]} newSources - The new array of sources.\r\n     * @memberof Mapping#\r\n     */\r\n    map: function(newSources) {\r\n      let newKeys = newSources.map(getSourceKey);\r\n      let oldTargets = results.slice();\r\n      let oldIndex = 0;\r\n      for (let i=0;i<newSources.length;i++) {\r\n        let source = newSources[i];\r\n        let sourceKey = newKeys[i];\r\n        if (sourceKey === keys[oldIndex]) {\r\n          results[i] = oldTargets[oldIndex];\r\n          updateResult(source, oldTargets[oldIndex], i);\r\n          oldIndex++;\r\n        } else {\r\n          let found = false;\r\n          for (let j = 1; j < keys.length; j++) {\r\n            let searchIndex = (oldIndex + j) % keys.length;\r\n            if (keys[searchIndex] === sourceKey) {\r\n              results[i] = oldTargets[searchIndex];\r\n              updateResult(newSources[i], oldTargets[searchIndex], i);\r\n              oldIndex = searchIndex + 1;\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!found) {\r\n            results[i] = createResult(source, i);\r\n          }\r\n        }\r\n      }\r\n      results.length = newSources.length;\r\n      keys = newKeys;\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a {@link Projector} instance using the provided projectionOptions.\r\n * @param {Object} [projectionOptions] - Options that influence how the DOM is rendered and updated.\r\n * @param {Object} projectionOptions.transitions - A transition strategy to invoke when \r\n * enterAnimation and exitAnimation properties are provided as strings.\r\n * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy. \r\n * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\r\n * @returns {Projector}\r\n */\r\nexport let createProjector = function (projectionOptions) {\r\n  projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n  projectionOptions.eventHandlerInterceptor = function (propertyName, functionPropertyArgument) {\r\n    return function () {\r\n      // intercept function calls (event handlers) to do a render afterwards.\r\n      projector.scheduleRender();\r\n      return functionPropertyArgument.apply(this, arguments);\r\n    };\r\n  };\r\n  let renderCompleted = true;\r\n  let scheduled;\r\n  let stopped = false;\r\n  let projections = [];\r\n  let renderFunctions = []; // matches the projections array\r\n\r\n  let doRender = function () {\r\n    scheduled = undefined;\r\n    if (!renderCompleted) {\r\n      return; // The last render threw an error, it should be logged in the browser console. \r\n    }\r\n    renderCompleted = false;\r\n    for(let i = 0; i < projections.length; i++) {\r\n      let updatedVnode = renderFunctions[i]();\r\n      projections[i].update(updatedVnode);\r\n    }\r\n    renderCompleted = true;\r\n  };\r\n\r\n  var projector = {\r\n    /**\r\n     * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\r\n     * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\r\n     * You need to call this method for instance when timeouts expire or AJAX responses arrive.\r\n     * @memberof Projector#\r\n     */\r\n    scheduleRender: function () {\r\n      if(!scheduled && !stopped) {\r\n        scheduled = requestAnimationFrame(doRender);\r\n      }\r\n    },\r\n    /**\r\n     * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\r\n     * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected as usual if it is no longer in scope.\r\n     * @memberof Projector#\r\n     */\r\n    stop: function () {\r\n      if(scheduled) {\r\n        cancelAnimationFrame(scheduled);\r\n        scheduled = undefined;\r\n      }\r\n      stopped = true;\r\n    },\r\n    \r\n    /**\r\n     * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\r\n     * @memberof Projector#\r\n     */\r\n    resume: function() {\r\n      stopped = false;\r\n      renderCompleted = true;\r\n      projector.scheduleRender();\r\n    },\r\n    \r\n    /**\r\n     * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} parentNode - The parent node for the new childNode.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    append: function (parentNode, renderMaquetteFunction) {\r\n      projections.push(dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} beforeNode - The node that the DOM Node is inserted before.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    insertBefore: function (beforeNode, renderMaquetteFunction) {\r\n      projections.push(dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\r\n     * This means that the virtual DOM and real DOM have one overlapping element. \r\n     * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.  \r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    merge: function (domNode, renderMaquetteFunction) {\r\n      projections.push(dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    },\r\n    \r\n    /**\r\n     * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\r\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\r\n     * @param {Element} domNode - The DOM node to replace.\r\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\r\n     * @memberof Projector#\r\n     */\r\n    replace: function (domNode, renderMaquetteFunction) {\r\n      let vnode = renderMaquetteFunction();\r\n      createDom(vnode, domNode.parentNode, domNode, projectionOptions);\r\n      domNode.parentNode.removeChild(domNode);\r\n      projections.push(createProjection(vnode, projectionOptions));\r\n      renderFunctions.push(renderMaquetteFunction);\r\n    }\r\n  };\r\n  return projector;\r\n};\r\n"],"sourceRoot":"/source/"}