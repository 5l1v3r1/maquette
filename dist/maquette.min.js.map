{"version":3,"sources":["maquette.js","/source/maquette.ts"],"names":["root","factory","define","amd","exports","nodeName","maquette","this","createDom","updateDom","NAMESPACE_SVG","emptyArray","extend","base","overrides","result","Object","keys","forEach","key","same","vnode1","vnode2","vnodeSelector","properties","toTextVNode","data","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectionOptions","checkStyleValue","styleValue","setProperties","propNames","propCount","propName","propValue","classNames","classNameCount","j","className","classList","add","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","target","apply","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","c","found","document","createTextNode","appendChild","charAt","slice","id","createElementNS","createElement","previous","updated","nodeValue","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","append","beforeNode","merge","element","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","propertyName","functionPropertyArgument","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","replace"],"mappings":"CAAC,SAAUA,EAAMC,GACS,kBAAXC,SAAyBA,OAAOC,IAEvCD,QAAQ,WAAYD,GAGpBA,EAF0B,gBAAZG,UAAoD,gBAArBA,SAAQC,SAE7CD,QAGAJ,EAAKM,cAEnBC,KAAM,SAAUH,GCkLlB,GAkTII,GACAC,EAnTEC,EAAgB,6BAIlBC,KAEAC,EAAS,SAAIC,EAASC,GACxB,GAAIC,KASJ,OARAC,QAAOC,KAAKJ,GAAMK,QAAQ,SAASC,GACjCJ,EAAOI,GAAQN,EAAaM,KAE1BL,GACFE,OAAOC,KAAKH,GAAWI,QAAQ,SAASC,GACtCJ,EAAOI,GAAOL,EAAUK,KAGrBJ,GAKLK,EAAO,SAASC,EAAeC,GACjC,MAAID,GAAOE,gBAAkBD,EAAOC,eAC3B,EAELF,EAAOG,YAAcF,EAAOE,WACvBH,EAAOG,WAAWL,MAAQG,EAAOE,WAAWL,KAE7CE,EAAOG,aAAeF,EAAOE,YAGnCC,EAAc,SAACC,GACjB,OACEH,cAAe,GACfC,WAAYG,OACZC,SAAUD,OACVE,KAAgB,OAATH,GAA0BC,SAATD,EAAsB,GAAKA,EAAKI,WACxDC,QAAS,OAITC,EAAiB,SAASC,EAAwBC,EAAmBC,GACvE,IAAK,GAAIC,GAAI,EAAGA,EAAIF,EAAWG,OAAQD,IAAK,CAC1C,GAAIE,GAAOJ,EAAWE,EAClBG,OAAMC,QAAQF,GAChBN,EAAeC,EAAgBK,EAAMH,GAExB,OAATG,GAA0BX,SAATW,IACdA,EAAKG,eAAe,mBACvBH,EAAOb,EAAYa,IAErBH,EAAKO,KAAKJ,MAQdK,EAAoB,WACtB,KAAM,IAAIC,OAAM,2EAGZC,GACJC,UAAWnB,OACXoB,wBAAyBpB,OACzBqB,aAAc,SAASjB,EAAsBkB,EAAmBC,GAE7DnB,EAAQoB,MAAcF,GAAaC,GAEtCE,aACEC,MAAOV,EACPW,KAAMX,IAINY,EAAgC,SAASC,GAC3C,MAAO5C,GAAOiC,EAA4BW,IAGxCC,EAAkB,SAASC,GAC7B,GAA0B,gBAAfA,GACT,KAAM,IAAId,OAAM,iCAIhBe,EAAgB,SAAS5B,EAAeP,EAA6BgC,GACvE,GAAKhC,EAML,IAAK,GAHDuB,GAA0BS,EAAkBT,wBAC5Ca,EAAY5C,OAAOC,KAAKO,GACxBqC,EAAYD,EAAUvB,OACjBD,EAAI,EAAOyB,EAAJzB,EAAeA,IAAK,CAClC,GAAI0B,GAAWF,EAAUxB,GAErB2B,EAAYvC,EAAWsC,EAE3B,IAAiB,UAAbA,GAAqC,cAAbA,GAAyC,cAAbA,EACtD,KAAM,IAAIlB,OAAM,YAAckB,EAAW,kCACpC,IAAiB,YAAbA,EAIT,IAAK,GAFDE,GAAahD,OAAOC,KAAK8C,GACzBE,EAAiBD,EAAW3B,OACvB6B,EAAI,EAAOD,EAAJC,EAAoBA,IAAK,CACvC,GAAIC,GAAYH,EAAWE,EACvBH,GAAUI,IACXpC,EAAoBqC,UAAUC,IAAIF,OAGlC,IAAiB,WAAbL,EAIT,IAAK,GAFDQ,GAAatD,OAAOC,KAAK8C,GACzBQ,EAAaD,EAAWjC,OACnB6B,EAAI,EAAOK,EAAJL,EAAgBA,IAAK,CACnC,GAAIjB,GAAYqB,EAAWJ,GACvBR,EAAaK,EAAUd,EACvBS,KACFD,EAAgBC,GAChBF,EAAkBR,aAA0BjB,EAASkB,EAAWS,QAG/D,CAAA,GAAiB,QAAbI,EACT,QACK,IAAkB,OAAdC,GAAoCpC,SAAdoC,EAC/B,QAEA,IAAIS,SAAcT,EACL,cAATS,GACEzB,GAA8D,IAAlCe,EAASW,YAAY,KAAM,KACzDV,EAAYhB,EAAwBe,EAAUC,EAAWhC,EAASP,GACjD,YAAbsC,IACD,WAEC,GAAIY,GAAeX,CACnBA,GAAY,SAASY,GAClBA,EAAIC,OAAe,iBAAoBD,EAAIC,OAA4B1B,MACxEwB,EAAaG,MAAMtE,MAAOoE,SAKjC5C,EAAgB+B,GAAYC,GACX,WAATS,GAAkC,UAAbV,EAC7B/B,EAAoB+C,aAAahB,EAAUC,GAE3ChC,EAAgB+B,GAAYC,KAMjCgB,EAAmB,SAAShD,EAAeiD,EAAqCxD,EAA6BgC,GAC/G,GAAKhC,EAAL,CAMA,IAAK,GAHDyD,IAAoB,EACpBrB,EAAY5C,OAAOC,KAAKO,GACxBqC,EAAYD,EAAUvB,OACjBD,EAAI,EAAOyB,EAAJzB,EAAeA,IAAK,CAClC,GAAI0B,GAAWF,EAAUxB,GAErB2B,EAAYvC,EAAWsC,GACvBoB,EAAgBF,EAAmBlB,EACvC,IAAiB,YAAbA,EAIF,IAAK,GAHDM,GAAarC,EAAoBqC,UACjCJ,EAAahD,OAAOC,KAAK8C,GACzBE,EAAiBD,EAAW3B,OACvB6B,EAAI,EAAOD,EAAJC,EAAoBA,IAAK,CACvC,GAAIC,GAAYH,EAAWE,GACvBiB,IAAOpB,EAAUI,GACjBiB,IAAeF,EAAcf,EAC7BgB,KAAOC,IAGXH,GAAoB,EAChBE,EACFf,EAAUC,IAAIF,GAEdC,EAAUiB,OAAOlB,QAGhB,IAAiB,WAAbL,EAGT,IAAK,GAFDQ,GAAatD,OAAOC,KAAK8C,GACzBQ,EAAaD,EAAWjC,OACnB6B,EAAI,EAAOK,EAAJL,EAAgBA,IAAK,CACnC,GAAIjB,GAAYqB,EAAWJ,GACvBoB,EAAgBvB,EAAUd,GAC1BsC,EAAgBL,EAAcjC,EAC9BqC,KAAkBC,IAGtBN,GAAoB,EAChBK,GACF7B,EAAgB6B,GAChB9B,EAAkBR,aAAajB,EAAwBkB,EAAWqC,IAElE9B,EAAkBR,aAAajB,EAAwBkB,EAAW,SAOtE,IAHKc,GAAsC,gBAAlBmB,KACvBnB,EAAY,IAEG,UAAbD,EACG/B,EAAgB+B,KAAcC,GAAchC,EAAgB,mBAAqBgC,IACnFhC,EAAgB+B,GAAYC,EAC5BhC,EAAgB,iBAAmBJ,QAElCoC,IAAcmB,IAChBD,GAAoB,OAEjB,IAAIlB,IAAcmB,EAAe,CACtC,GAAIV,SAAcT,EAClB,IAAa,aAATS,EACF,KAAM,IAAI5B,OAAM,iEAAmEkB,EACjF,0EAES,YAATU,EACDzC,EAAoB+C,aAAahB,EAAUC,GAEvChC,EAAgB+B,KAAcC,IAChChC,EAAgB+B,GAAYC,GAGjCkB,GAAoB,GAI1B,MAAOA,KAGLO,EAAmB,SAAS5D,EAAmB6D,EAAeC,GAChE,GAA6B,KAAzBD,EAAOlE,cAET,IAAK,GAAIa,GAAIsD,EAAOtD,EAAIR,EAASS,OAAQD,IACvC,GAAIhB,EAAKQ,EAASQ,GAAIqD,GACpB,MAAOrD,EAIb,OAAO,IAGLuD,EAAY,SAASC,EAAcxC,GACrC,GAAIwC,EAAMpE,WAAY,CACpB,GAAIqE,GAAiBD,EAAMpE,WAAWqE,cAClCA,KAC4B,kBAAnBA,GACTA,EAAeD,EAAM7D,QAAoB6D,EAAMpE,YAE/C4B,EAAYC,MAAMuC,EAAM7D,QAAoB6D,EAAMpE,WAAYqE,MAMlEC,EAAe,SAASF,EAAcxC,GACxC,GAAIrB,GAAU6D,EAAM7D,OACpB,IAAI6D,EAAMpE,WAAY,CACpB,GAAIuE,GAAgBH,EAAMpE,WAAWuE,aACrC,IAAIA,EAAe,CAChBhE,EAAwBoB,MAAM6C,cAAgB,MAC/C,IAAIC,GAAgB,WACdlE,EAAQmE,YACVnE,EAAQmE,WAAWC,YAAYpE,GAGnC,OAA6B,kBAAlBgE,OACTA,GAAchE,EAAoBkE,EAAeL,EAAMpE,gBAGvD4B,GAAYE,KAAKsC,EAAM7D,QAAoB6D,EAAMpE,WAAYuE,EAAyBE,IAKxFlE,EAAQmE,YACVnE,EAAQmE,WAAWC,YAAYpE,IAI/BqE,EAAuB,SAASC,EAAqBC,EAAsBC,EAAoBC,GACjG,GAAIC,GAAYJ,EAAWC,EAC3B,IAAgC,KAA5BG,EAAUlF,cAAd,CAGA,GAAIJ,GAAMsF,EAAUjF,WAAaiF,EAAUjF,WAAWL,IAAMQ,MAC5D,KAAKR,EACH,IAAK,GAAIiB,GAAI,EAAGA,EAAIiE,EAAWhE,OAAQD,IACrC,GAAIA,IAAMkE,EAAc,CACtB,GAAII,GAAOL,EAAWjE,EACtB,IAAIhB,EAAKsF,EAAMD,GACb,KAAkB,UAAdD,EACI,GAAI5D,OAAM2D,EAAYhF,cAAgB,UAAYkF,EAAUlF,cAAgB,kHAG5E,GAAIqB,OAAM2D,EAAYhF,cAAgB,UAAYkF,EAAUlF,cAAgB,qHAY1FoF,EAAiB,SAASC,EAAc7E,EAAe8E,EAAsBC,EAAsBtD,GACrG,GAAIqD,IAAgBC,EAClB,OAAO,CAETD,GAAcA,GAAelG,EAC7BmG,EAAcA,GAAenG,CAS7B,KARA,GAMIyB,GANA2E,EAAoBF,EAAYxE,OAChC2E,EAAoBF,EAAYzE,OAChCe,EAAcI,EAAkBJ,YAEhC6D,EAAW,EACXC,EAAW,EAEXC,GAAc,EACAH,EAAXE,GAA8B,CACnC,GAAIE,GAAuBL,EAAXE,EAAgCJ,EAAYI,GAAYtF,OACpE0F,EAAWP,EAAYI,EAC3B,IAAiBvF,SAAbyF,GAA0BhG,EAAKgG,EAAUC,GAC3CF,EAAc1G,EAAU2G,EAAUC,EAAU7D,IAAsB2D,EAClEF,QACK,CACL,GAAIK,GAAe9B,EAAiBqB,EAAaQ,EAAUJ,EAAW,EACtE,IAAIK,GAAgB,EAAG,CAErB,IAAKlF,EAAI6E,EAAcK,EAAJlF,EAAkBA,IACnC0D,EAAae,EAAYzE,GAAIgB,GAC7BgD,EAAqBS,EAAazE,EAAGwE,EAAO,UAE9CO,GAAc1G,EAAUoG,EAAYS,GAAeD,EAAU7D,IAAsB2D,EACnFF,EAAWK,EAAe,MAG1B9G,GAAU6G,EAAUtF,EAAqBgF,EAAXE,EAAgCJ,EAAYI,GAAUlF,QAAUJ,OAAW6B,GACzGmC,EAAU0B,EAAUjE,GACpBgD,EAAqBU,EAAaI,EAAUN,EAAO,SAGvDM,IAEF,GAAIH,EAAoBE,EAEtB,IAAK7E,EAAI6E,EAAcF,EAAJ3E,EAAuBA,IACxC0D,EAAae,EAAYzE,GAAIgB,GAC7BgD,EAAqBS,EAAazE,EAAGwE,EAAO,UAGhD,OAAOO,IAGLI,EAAc,SAASxF,EAAeH,EAAmB4B,GAC3D,GAAK5B,EAGL,IAAK,GAAIQ,GAAI,EAAGA,EAAIR,EAASS,OAAQD,IACnC5B,EAAUoB,EAASQ,GAAIL,EAASJ,OAAW6B,IAI3CgE,EAA4B,SAASzF,EAAe6E,EAAcpD,GACpE+D,EAAYxF,EAAS6E,EAAMhF,SAAU4B,GACjCoD,EAAM/E,OACRE,EAAQ0F,YAAcb,EAAM/E,MAE9B8B,EAAc5B,EAAS6E,EAAMpF,WAAYgC,GACrCoD,EAAMpF,YAAcoF,EAAMpF,WAAWkG,aACvCd,EAAMpF,WAAWkG,YAAY3F,EAAoByB,EAAmBoD,EAAMrF,cAAeqF,EAAMpF,WAAYoF,EAAMhF,UAIrHpB,GAAY,SAASoG,EAAOV,EAAYyB,EAAcnE,GACpD,GAAIzB,GAAeK,EAAWwF,EAAsBpD,EAAcqD,EAAzBnC,EAAQ,EAC7CnE,EAAgBqF,EAAMrF,aAC1B,IAAsB,KAAlBA,EACFQ,EAAU6E,EAAM7E,QAAU+F,SAASC,eAAenB,EAAM/E,MACnCF,SAAjBgG,EACFzB,EAAWyB,aAAa5F,EAAS4F,GAEjCzB,EAAW8B,YAAYjG,OAEpB,CACL,IAAKK,EAAI,EAAGA,GAAKb,EAAcc,SAAUD,EACvCwF,EAAIrG,EAAc0G,OAAO7F,IACrBA,IAAMb,EAAcc,QAAgB,MAANuF,GAAmB,MAANA,KAC7CpD,EAAOjD,EAAc0G,OAAOvC,EAAQ,GACpCmC,EAAQtG,EAAc2G,MAAMxC,EAAOtD,GACtB,MAAToC,EACDzC,EAAwBqC,UAAUC,IAAIwD,GACrB,MAATrD,EACRzC,EAAoBoG,GAAKN,GAEZ,QAAVA,IACFrE,EAAoB5C,EAAO4C,GAAqBV,UAAWpC,KAG3DqB,EADkCJ,SAAhC6B,EAAkBV,UACV8D,EAAM7E,QAAU+F,SAASM,gBAAgB5E,EAAkBV,UAAW+E,GAEtEjB,EAAM7E,QAAU+F,SAASO,cAAcR,GAE9BlG,SAAjBgG,EACFzB,EAAWyB,aAAa5F,EAAS4F,GAEjCzB,EAAW8B,YAAYjG,IAG3B2D,EAAQtD,EAAI,EAGhBoF,GAA0BzF,EAAS6E,EAAOpD,KAI9C/C,EAAY,SAAS6H,EAAU1B,EAAOpD,GACpC,GAAIzB,GAAUuG,EAASvG,OACvB,KAAKA,EACH,KAAM,IAAIa,OAAM,iCAElB,IAAIuE,IAAc,CAClB,IAAImB,IAAa1B,EACf,MAAOO,EAET,IAAIoB,IAAU,CA4Bd,OA3B4B,KAAxB3B,EAAMrF,cACJqF,EAAM/E,OAASyG,EAASzG,OAC1BE,EAAQyG,UAAY5B,EAAM/E,KAC1BsF,GAAc,IAGkC,IAA9CP,EAAMrF,cAAckD,YAAY,MAAO,KACzCjB,EAAoB5C,EAAO4C,GAAqBV,UAAWpC,KAEzD4H,EAASzG,OAAS+E,EAAM/E,OAC1B0G,GAAU,EACS5G,SAAfiF,EAAM/E,KACRE,EAAQoE,YAAYpE,EAAQ0G,YAE5B1G,EAAQ0F,YAAcb,EAAM/E,MAGhC0G,EAAU5B,EAAeC,EAAO7E,EAASuG,EAAS1G,SAAUgF,EAAMhF,SAAU4B,IAAsB+E,EAClGA,EAAUxD,EAAiBhD,EAASuG,EAAS9G,WAAYoF,EAAMpF,WAAYgC,IAAsB+E,EAC7F3B,EAAMpF,YAAcoF,EAAMpF,WAAWkH,aACvC9B,EAAMpF,WAAWkH,YAAqB3G,EAASyB,EAAmBoD,EAAMrF,cAAeqF,EAAMpF,WAAYoF,EAAMhF,WAG/G2G,GAAW3B,EAAMpF,YAAcoF,EAAMpF,WAAWmH,iBAClD/B,EAAMpF,WAAWmH,gBAAyB5G,EAAS6E,EAAMpF,WAAY8G,EAAS9G,YAEhFoF,EAAM7E,QAAUuG,EAASvG,QAClBoF,EAOT,IAAIyB,GAAmB,SAAShC,EAAcpD,GAC5C,IAAKoD,EAAMrF,cACT,KAAM,IAAIqB,OAAM,yBAElB,QAMEiG,OAAQ,SAASC,GACf,GAAIlC,EAAMrF,gBAAkBuH,EAAavH,cACvC,KAAM,IAAIqB,OAAM,4HAElBnC,GAAUmG,EAAOkC,EAActF,GAC/BoD,EAAQkC,GAOV/G,QAAkB6E,EAAM7E,SA2HjB3B,GAAA2I,EAAI,SAASC,GACtB,GAAIxH,GAAayH,UAAU,EAC3B,IAAwB,gBAAbD,GACT,KAAM,IAAIpG,MAEZ,IAAIsG,GAAa,GACb1H,GAAeA,EAAWiB,eAAe,kBAAqBF,MAAMC,QAAQhB,IAAqC,gBAAfA,GAIpGA,EAAaG,OAHbuH,EAAa,CAKf,IAAIrH,GAAOF,OACPC,EAAWD,OACXwH,EAAaF,UAAU5G,MAE3B,IAAI8G,IAAeD,EAAa,EAAG,CACjC,GAAIE,GAAYH,UAAUC,EACD,iBAAdE,GACTvH,EAAOuH,EACgBzH,SAAdyH,GAAgD,IAArBA,EAAU/G,QAAwC,gBAAjB+G,GAAU,KAC/EvH,EAAOuH,EAAU,IAGrB,GAAazH,SAATE,EAEF,IADAD,KACOsH,EAAaD,UAAU5G,OAAQ6G,IAAc,CAClD,GAAIG,GAAQJ,UAAUC,EACR,QAAVG,GAA4B1H,SAAV0H,IAEX9G,MAAMC,QAAQ6G,GACvBrH,EAAegH,EAAUK,EAAOzH,GACvByH,EAAM5G,eAAe,iBAC9Bb,EAASc,KAAK2G,GAEdzH,EAASc,KAAKjB,EAAY4H,KAIhC,OACE9H,cAAeyH,EACfxH,WAAYA,EACZI,SAAUA,EACVC,KAAMA,EACNE,QAAS,OAOF3B,EAAAkJ,KAWTC,OAAQ,SAAS3C,EAAcpD,GAG7B,MAFAA,GAAoBD,EAA8BC,GAClDhD,EAAUoG,EAAOkB,SAASO,cAAc,OAAQ1G,OAAW6B,GACpDoF,EAAiBhC,EAAOpD,IAajCgG,OAAQ,SAAStD,EAAqBU,EAAcpD,GAGlD,MAFAA,GAAoBD,EAA8BC,GAClDhD,EAAUoG,EAAOV,EAAYvE,OAAW6B,GACjCoF,EAAiBhC,EAAOpD,IAajCmE,aAAc,SAAS8B,EAAqB7C,EAAcpD,GAGxD,MAFAA,GAAoBD,EAA8BC,GAClDhD,EAAUoG,EAAO6C,EAAWvD,WAAYuD,EAAYjG,GAC7CoF,EAAiBhC,EAAOpD,IAejCkG,MAAO,SAASC,EAAkB/C,EAAcpD,GAI9C,MAHAA,GAAoBD,EAA8BC,GAClDoD,EAAM7E,QAAU4H,EAChBnC,EAA0BmC,EAAS/C,EAAOpD,GACnCoF,EAAiBhC,EAAOpD,KASxBpD,EAAAwJ,YAAc,WACvB,GAAIC,GAAelI,OACfmI,EAAgBnI,OAChBZ,GAKFgJ,WAAY,WACVD,EAAgBnI,OAChBkI,EAAelI,QAWjBZ,OAAQ,SAASiJ,EAAkBC,GACjC,GAAIJ,EACF,IAAK,GAAIzH,GAAI,EAAGA,EAAI4H,EAAO3H,OAAQD,IAC7ByH,EAAazH,KAAO4H,EAAO5H,KAC7B0H,EAAgBnI,OAQtB,OAJKmI,KACHA,EAAgBG,IAChBJ,EAAeG,GAEVF,GAGX,OAAO/I,IAWEX,EAAA8J,cAAgB,SACzBC,EACAC,EACAC,GAEA,GAAIpJ,MACAqJ,IAEJ,QAMEA,QAASA,EAMTC,IAAK,SAASC,GAIZ,IAAK,GAHDC,GAAUD,EAAWD,IAAIJ,GACzBO,EAAaJ,EAAQpC,QACrBjB,EAAW,EACN7E,EAAI,EAAGA,EAAIoI,EAAWnI,OAAQD,IAAK,CAC1C,GAAIuI,GAASH,EAAWpI,GACpBwI,EAAYH,EAAQrI,EACxB,IAAIwI,IAAc3J,EAAKgG,GACrBqD,EAAQlI,GAAKsI,EAAWzD,GACxBoD,EAAaM,EAAQD,EAAWzD,GAAW7E,GAC3C6E,QACK,CAEL,IAAK,GADDY,IAAQ,EACH3D,EAAI,EAAGA,EAAIjD,EAAKoB,OAAQ6B,IAAK,CACpC,GAAI2G,IAAe5D,EAAW/C,GAAKjD,EAAKoB,MACxC,IAAIpB,EAAK4J,KAAiBD,EAAW,CACnCN,EAAQlI,GAAKsI,EAAWG,GACxBR,EAAaG,EAAWpI,GAAIsI,EAAWG,GAAczI,GACrD6E,EAAW4D,EAAc,EACzBhD,GAAQ,CACR,QAGCA,IACHyC,EAAQlI,GAAKgI,EAAaO,EAAQvI,KAIxCkI,EAAQjI,OAASmI,EAAWnI,OAC5BpB,EAAOwJ,KAcFrK,EAAA0K,gBAAkB,SAAStH,GACpC,GAAIuH,EACJvH,GAAoBD,EAA8BC,GAClDA,EAAkBT,wBAA0B,SAASiI,EAAsBC,GACzE,MAAO,YAGL,MADAF,GAAUG,iBACHD,EAAyBpG,MAAMtE,KAAM0I,YAGhD,IACIkC,GADAC,GAAkB,EAElBC,GAAU,EACVC,KACAC,KAEAC,EAAW,WAEb,GADAL,EAAYxJ,OACPyJ,EAAL,CAGAA,GAAkB,CAClB,KAAK,GAAIhJ,GAAI,EAAGA,EAAIkJ,EAAYjJ,OAAQD,IAAK,CAC3C,GAAI0G,GAAeyC,EAAgBnJ,IACnCkJ,GAAYlJ,GAAGyG,OAAOC,GAExBsC,GAAkB,GA4FpB,OAzFAL,IAOEG,eAAgB,WACTC,GAAcE,IACjBF,EAAYM,sBAAsBD,KAStCE,KAAM,WACAP,IACFQ,qBAAqBR,GACrBA,EAAYxJ,QAEd0J,GAAU,GAOZO,OAAQ,WACNP,GAAU,EACVD,GAAkB,EAClBL,EAAUG,kBAUZ1B,OAAQ,SAAStD,EAAY2F,GAC3BP,EAAY5I,KAAKtC,EAAAkJ,IAAIE,OAAOtD,EAAY2F,IAA0BrI,IAClE+H,EAAgB7I,KAAKmJ,IAUvBlE,aAAc,SAAS8B,EAAYoC,GACjCP,EAAY5I,KAAKtC,EAAAkJ,IAAI3B,aAAa8B,EAAYoC,IAA0BrI,IACxE+H,EAAgB7I,KAAKmJ,IAYvBnC,MAAO,SAAS3H,EAAS8J,GACvBP,EAAY5I,KAAKtC,EAAAkJ,IAAII,MAAM3H,EAAS8J,IAA0BrI,IAC9D+H,EAAgB7I,KAAKmJ,IAUvBC,QAAS,SAAS/J,EAAS8J,GACzB,GAAIjF,GAAQiF,GACZrL,GAAUoG,EAAO7E,EAAQmE,WAAYnE,EAASyB,GAC9CzB,EAAQmE,WAAWC,YAAYpE,GAC/BuJ,EAAY5I,KAAKkG,EAAiBhC,EAAOpD,IACzC+H,EAAgB7I,KAAKmJ","file":"maquette.min.js","sourcesContent":["(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    ;\n    ;\n    ;\n    var NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            return vnode1.properties.key === vnode2.properties.key;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data === null || data === undefined ? '' : data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0; i < insertions.length; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectionOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectionOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'class' || propName === 'className' || propName === 'classList') {\n                throw new Error('Property ' + propName + ' is not supported, use classes.');\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (eventHandlerInterceptor && propName.lastIndexOf('on', 0) === 0) {\n                        propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);\n                        // intercept eventhandlers\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                    }\n                    domNode[propName] = propValue;\n                } else if (type === 'string' && propName !== 'value') {\n                    domNode.setAttribute(propName, propValue);\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string') {\n                        domNode.setAttribute(propName, propValue);\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var key = childNode.properties ? childNode.properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        if (!domNode) {\n            throw new Error('previous node was not rendered');\n        }\n        var textUpdated = false;\n        if (previous === vnode) {\n            return textUpdated;    // we assume that nothing has changed\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                domNode.nodeValue = vnode.text;\n                textUpdated = true;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    /**\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\n * @interface Projection\n */\n    var createProjection = function (vnode, projectionOptions) {\n        if (!vnode.vnodeSelector) {\n            throw new Error('Invalid vnode argument');\n        }\n        return {\n            /**\n         * Updates the projection with the new virtual DOM tree.\n         * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant.\n         * @memberof Projection#\n         */\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            /**\n         * The DOM node that is used as the root of this {@link Projection}.\n         * @type {Element}\n         * @memberof Projection#\n         */\n            domNode: vnode.domNode\n        };\n    };\n    // Declaration of interfaces and callbacks, before the @exports maquette\n    /**\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs.\n * On subsequent calls the previous outcome is returned if the inputs are identical.\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\n * Instances of {@link CalculationCache} can be created using {@link module:maquette.createCache}.\n * @interface CalculationCache\n */\n    /**\n * Keeps an array of result objects synchronized with an array of source objects.\n * Mapping provides a {@link Mapping#map} function that updates the {@link Mapping#results}.\n * The {@link Mapping#map} function can be called multiple times and the results will get created, removed and updated accordingly.\n * A {@link Mapping} can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\n * Instances of {@link Mapping} can be created using {@link module:maquette.createMapping}.\n * @interface Mapping\n */\n    /**\n * Used to create and update the DOM.\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace}\n * to create the DOM.\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions\n * will be called again to update the DOM on the next animation-frame after:\n *\n *  - The {@link Projector#scheduleRender} function  was called\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\n *\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\n * @interface Projector\n */\n    /**\n * @callback enterAnimationCallback\n * @param {Element} element - Element that was just added to the DOM.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback exitAnimationCallback\n * @param {Element} element - Element that ought to be removed from to the DOM.\n * @param {function(Element)} removeElement - Function that removes the element from the DOM.\n * This argument is supplied purely for convenience.\n * You may use this function to remove the element when the animation is done.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method that rendered this {@link VNode}\n * the previous time.\n */\n    /**\n * @callback updateAnimationCallback\n * @param {Element} element - Element that was modified in the DOM.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback afterCreateCallback\n * @param {Element} element - The element that was added to the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children that were created.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n    /**\n * @callback afterUpdateCallback\n * @param {Element} element - The element that may have been updated in the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children for this node.\n */\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM. The singleton instance is available under {@link module:maquette.dom}.\n * @interface MaquetteDom\n */\n    /**\n * The `h` method is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * @param {string} selector - Contains the tagName, id and fixed css classnames in CSS selector format.\n * It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n * @param {Object} [properties] - An object literal containing properties that will be placed on the DOM node.\n * @param {function} properties.<b>*</b> - Properties with functions values like `onclick:handleClick` are registered as event handlers\n * @param {String} properties.<b>*</b> - Properties with string values, like `href:'/'` are used as attributes\n * @param {object} properties.<b>*</b> - All non-string values are put on the DOM node as properties\n * @param {Object} properties.key - Used to uniquely identify a DOM node among siblings.\n * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n * @param {Object} properties.classes - An object literal like `{important:true}` which allows css classes, like `important` to be added and removed\n * dynamically.\n * @param {Object} properties.styles - An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\n * @param {(string|enterAnimationCallback)} properties.enterAnimation - The animation to perform when this node is added to an already existing parent.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * @param {(string|exitAnimationCallback)} properties.exitAnimation - The animation to perform when this node is removed while its parent remains.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {updateAnimationCallback} properties.updateAnimation - The animation to perform when the properties of this node change.\n * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {afterCreateCallback} properties.afterCreate - Callback that is executed after this node is added to the DOM. Childnodes and properties have\n * already been applied.\n * @param {afterUpdateCallback} properties.afterUpdate - Callback that is executed every time this node may have been updated. Childnodes and properties\n * have already been updated.\n * @param {Object[]} [children] - An array of virtual DOM nodes to add as child nodes.\n * This array may contain nested arrays, `null` or `undefined` values.\n * Nested arrays are flattened, `null` and `undefined` will be skipped.\n *\n * @returns {VNode} A VNode object, used to render a real DOM later.\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\n */\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < arguments.length; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text,\n            domNode: null\n        };\n    };\n    /**\n * @type MaquetteDom\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from a {@link VNode}. The {@link Projection} object returned will contain the resulting DOM Node under\n     * the {@link Projection#domNode} property.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode}\n     * objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} which contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a {@link VNode}.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} parentNode - The parent node for the new childNode.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode}\n     * objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a {@link VNode}.\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function.\n     * NOTE: {@link VNode} objects may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a {@link VNode} with an existing DOM Node.\n     * This means that the virtual DOM and real DOM have one overlapping element.\n     * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n     * This is a low-level method. Users wil typically use a {@link Projector} instead.\n     * @memberof MaquetteDom#\n     * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects\n     * may only be rendered once.\n     * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n     * @returns {Projection} The {@link Projection} that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a {@link CalculationCache} object, useful for caching {@link VNode} trees.\n * In practice, caching of {@link VNode} trees is not needed, because achieving 60 frames per second is almost never a problem.\n * @returns {CalculationCache}\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            /**\n         * Manually invalidates the cached outcome.\n         * @memberof CalculationCache#\n         */\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            /**\n         * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\n         * Otherwise, the calculation function is invoked and its result is cached and returned.\n         * Objects in the inputs array are compared using ===.\n         * @param {Object[]} inputs - Array of objects that are to be compared using === with the inputs from the previous invocation.\n         * These objects are assumed to be immutable primitive values.\n         * @param {function} calculation - Function that takes zero arguments and returns an object (A {@link VNode} assumably) that can be cached.\n         * @memberof CalculationCache#\n         */\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * @param {function} getSourceKey - `function(source)` that must return a key to identify each source object. The result must eather be a string or a number.\n * @param {function} createResult - `function(source, index)` that must create a new result object from a given source. This function is identical\n * argument of `Array.map`.\n * @param {function} updateResult - `function(source, target, index)` that updates a result to an updated source.\n * @returns {Mapping}\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            /**\n         * The array of results. These results will be synchronized with the latest array of sources that were provided using {@link Mapping#map}.\n         * @type {Object[]}\n         * @memberof Mapping#\n         */\n            results: results,\n            /**\n         * Maps a new array of sources and updates {@link Mapping#results}.\n         * @param {Object[]} newSources - The new array of sources.\n         * @memberof Mapping#\n         */\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a {@link Projector} instance using the provided projectionOptions.\n * @param {Object} [projectionOptions] - Options that influence how the DOM is rendered and updated.\n * @param {Object} projectionOptions.transitions - A transition strategy to invoke when\n * enterAnimation and exitAnimation properties are provided as strings.\n * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\n * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\n * @returns {Projector}\n */\n    exports.createProjector = function (projectionOptions) {\n        var projector;\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, functionPropertyArgument) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return functionPropertyArgument.apply(this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            /**\n         * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\n         * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\n         * You need to call this method for instance when timeouts expire or AJAX responses arrive.\n         * @memberof Projector#\n         */\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            /**\n         * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\n         * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected as usual\n         * if it is no longer in scope.\n         * @memberof Projector#\n         */\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            /**\n         * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\n         * @memberof Projector#\n         */\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            /**\n         * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} parentNode - The parent node for the new childNode.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\n         * This means that the virtual DOM and real DOM have one overlapping element.\n         * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            /**\n         * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\n         * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n         * @param {Element} domNode - The DOM node to replace.\n         * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n         * @memberof Projector#\n         */\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            }\n        };\n        return projector;\n    };\n}));","/**\n * A virtual representation of a DOM Node. Maquette assumes that {@link VNode} objects are never modified externally.\n * Instances of {@link VNode} can be created using {@link module:maquette.h}.\n */\nexport interface VNode {\n  /**\n   * The CSS selector containing tagname, css classnames and id. An empty string is used to denote a text node.\n   */\n  vnodeSelector: string;\n  /**\n   * Object containing attributes, properties, event handlers and more @see module:maquette.h\n   * @memberof VNode#\n   */\n  properties: VNodeProperties;\n  /**\n   * Array of VNodes to be used as children. This array is already flattened.\n   * @memberof VNode#\n   */\n  children: Array<VNode>;\n  /**\n   * Used in a special case when a VNode only has one childnode which is a textnode. Only used in combination with children === undefined.\n   */\n  text: string;\n  /**\n   * Used by maquette to store the domNode that was produced from this {@link VNode}.\n   */\n  domNode: Node;\n}\n\n/**\n * Used to create and update the DOM.\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace}\n * to create the DOM.\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions\n * will be called again to update the DOM on the next animation-frame after:\n *\n *  - The {@link Projector#scheduleRender} function  was called\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\n *\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\n */\nexport interface Projector {\n  /**\n   * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param {Element} parentNode - The parent node for the new childNode.\n   * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n   */\n  append(parentNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n   * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n   */\n  insertBefore(beforeNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\n   * This means that the virtual DOM and real DOM have one overlapping element.\n   * Therefore the selector for the root {VNode} will be ignored, but its properties and children will be applied to the Element provided\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n   * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n   */\n  merge(domNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\n   * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n   * @param {Element} domNode - The DOM node to replace.\n   * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n   */\n  replace(domNode: Element, renderMaquetteFunction: () => VNode): void;\n  /**\n   * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\n   */\n  resume(): void;\n  /**\n   * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\n   * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\n   * You need to call this method for instance when timeouts expire or AJAX responses arrive.\n   */\n  scheduleRender(): void;\n  /**\n   * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\n   * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected\n   * as usual if it is no longer in scope.\n   */\n  stop(): void;\n}\n\nexport interface Transitions {\n  enter: (element: Element, properties: VNodeProperties, enterAnimation: string) => void;\n  exit: (element: Element, properties: VNodeProperties, exitAnimation: string, removeElement: () => void) => void;\n};\n\nexport interface ProjectionOptions {\n  transitions?: Transitions;\n  /**\n   * Only for internal use.\n   */\n  namespace: string;\n  eventHandlerInterceptor: Function;\n  styleApplyer: (domNode: HTMLElement, styleName: string, value: string) => void;\n};\n\nexport interface VNodeProperties {\n  enterAnimation?: ((element: Element, properties?: VNodeProperties) => void) | string;\n  exitAnimation?: ((element: Element, removeElement: () => void, properties?: VNodeProperties) => void) | string;\n  updateAnimation?: (element: Element, properties?: VNodeProperties, previousProperties?: VNodeProperties) => void;\n  afterCreate?: (element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n    children: VNode[]) => void;\n  afterUpdate?: (element: Element, projectionOptions: ProjectionOptions, vnodeSelector: string, properties: VNodeProperties,\n    children: VNode[]) => void;\n  key?: Object;\n  classes?: {[index: string]: boolean};\n  styles?: {[index: string]: string};\n\n  // From Element\n  ontouchcancel?: (ev?: TouchEvent) => boolean|void;\n  ontouchend?: (ev?: TouchEvent) => boolean|void;\n  ontouchmove?: (ev?: TouchEvent) => boolean|void;\n  ontouchstart?: (ev?: TouchEvent) => boolean|void;\n  // From HTMLFormElement\n  action?: string;\n  encoding?: string;\n  enctype?: string;\n  method?: string;\n  name?: string;\n  target?: string;\n  // From HTMLElement\n  onblur?: (ev?: FocusEvent) => boolean|void;\n  onchange?: (ev?: Event) => boolean|void;\n  onclick?: (ev?: MouseEvent) => boolean|void;\n  ondblclick?: (ev?: MouseEvent) => boolean|void;\n  onfocus?: (ev?: FocusEvent) => boolean|void;\n  oninput?: (ev?: Event) => boolean|void;\n  onkeydown?: (ev?: KeyboardEvent) => boolean|void;\n  onkeypress?: (ev?: KeyboardEvent) => boolean|void;\n  onkeyup?: (ev?: KeyboardEvent) => boolean|void;\n  onload?: (ev?: Event) => boolean|void;\n  onmousedown?: (ev?: MouseEvent) => boolean|void;\n  onmouseenter?: (ev?: MouseEvent) => boolean|void;\n  onmouseleave?: (ev?: MouseEvent) => boolean|void;\n  onmousemove?: (ev?: MouseEvent) => boolean|void;\n  onmouseout?: (ev?: MouseEvent) => boolean|void;\n  onmouseover?: (ev?: MouseEvent) => boolean|void;\n  onmouseup?: (ev?: MouseEvent) => boolean|void;\n  onmousewheel?: (ev?: MouseWheelEvent) => boolean|void;\n  onscroll?: (ev?: UIEvent) => boolean|void;\n  onsubmit?: (ev?: Event) => boolean|void;\n  spellcheck?: boolean;\n  tabIndex?: number;\n  title?: string;\n  accessKey?: string;\n  id?: string;\n  // From HTMLInputElement\n  autocomplete?: string;\n  checked?: boolean;\n  placeholder?: string;\n  readOnly?: boolean;\n  src?: string;\n  value?: string;\n  // From HTMLImageElement\n  alt?: string;\n  srcset?: string;\n\n  // Everything else (uncommon or custom properties and attributes)\n  [index: string]: any;\n};\n\n/**\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\n */\nexport interface Projection {\n  /**\n   * The DOM node that is used as the root of this {@link Projection}.\n   * @type {Element}\n   */\n  domNode: Element;\n  /**\n   * Updates the projection with the new virtual DOM tree.\n   * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant.\n   */\n  update(updatedVnode: VNode): void;\n}\n\n\nconst NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\n\n// Utilities\n\nlet emptyArray = <VNode[]>[];\n\nlet extend = <T>(base: T, overrides: any): T => {\n  let result = {} as any;\n  Object.keys(base).forEach(function(key) {\n    result[key] = (base as any)[key];\n  });\n  if (overrides) {\n    Object.keys(overrides).forEach(function(key) {\n      result[key] = overrides[key];\n    });\n  }\n  return result;\n};\n\n// Hyperscript helper functions\n\nlet same = function(vnode1: VNode, vnode2: VNode) {\n  if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n    return false;\n  }\n  if (vnode1.properties && vnode2.properties) {\n    return vnode1.properties.key === vnode2.properties.key;\n  }\n  return !vnode1.properties && !vnode2.properties;\n};\n\nlet toTextVNode = (data: any): VNode => {\n  return {\n    vnodeSelector: '',\n    properties: undefined,\n    children: undefined,\n    text: (data === null || data === undefined) ? '' : data.toString(),\n    domNode: null\n  };\n};\n\nlet appendChildren = function(parentSelector: string, insertions: any[], main: VNode[]) {\n  for (let i = 0; i < insertions.length; i++) {\n    let item = insertions[i];\n    if (Array.isArray(item)) {\n      appendChildren(parentSelector, item, main);\n    } else {\n      if (item !== null && item !== undefined) {\n        if (!item.hasOwnProperty('vnodeSelector')) {\n          item = toTextVNode(item);\n        }\n        main.push(item);\n      }\n    }\n  }\n};\n\n// Render helper functions\n\nlet missingTransition = function() {\n  throw new Error('Provide a transitions object to the projectionOptions to do animations');\n};\n\nconst DEFAULT_PROJECTION_OPTIONS: ProjectionOptions = {\n  namespace: undefined,\n  eventHandlerInterceptor: undefined,\n  styleApplyer: function(domNode: HTMLElement, styleName: string, value: string) {\n    // Provides a hook to add vendor prefixes for browsers that still need it.\n    (domNode.style as any)[styleName] = value;\n  },\n  transitions: {\n    enter: missingTransition,\n    exit: missingTransition\n  }\n};\n\nlet applyDefaultProjectionOptions = function(projectionOptions: ProjectionOptions) {\n  return extend(DEFAULT_PROJECTION_OPTIONS, projectionOptions);\n};\n\nlet checkStyleValue = function(styleValue: Object) {\n  if (typeof styleValue !== 'string') {\n    throw new Error('Style values must be strings');\n  }\n};\n\nlet setProperties = function(domNode: Node, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\n  if (!properties) {\n    return;\n  }\n  let eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n  let propNames = Object.keys(properties);\n  let propCount = propNames.length;\n  for (let i = 0; i < propCount; i++) {\n    let propName = propNames[i];\n    /* tslint:disable:no-var-keyword: edge case */\n    var propValue = properties[propName];\n    /* tslint:enable:no-var-keyword */\n    if (propName === 'class' || propName === 'className' || propName === 'classList') {\n      throw new Error('Property ' + propName + ' is not supported, use classes.');\n    } else if (propName === 'classes') {\n      // object with string keys and boolean values\n      let classNames = Object.keys(propValue);\n      let classNameCount = classNames.length;\n      for (let j = 0; j < classNameCount; j++) {\n        let className = classNames[j];\n        if (propValue[className]) {\n          (domNode as Element).classList.add(className);\n        }\n      }\n    } else if (propName === 'styles') {\n      // object with string keys and string (!) values\n      let styleNames = Object.keys(propValue);\n      let styleCount = styleNames.length;\n      for (let j = 0; j < styleCount; j++) {\n        let styleName = styleNames[j];\n        let styleValue = propValue[styleName];\n        if (styleValue) {\n          checkStyleValue(styleValue);\n          projectionOptions.styleApplyer(<HTMLElement>domNode, styleName, styleValue);\n        }\n      }\n    } else if (propName === 'key') {\n      continue;\n    } else if (propValue === null || propValue === undefined) {\n      continue;\n    } else {\n      let type = typeof propValue;\n      if (type === 'function') {\n        if (eventHandlerInterceptor && (propName.lastIndexOf('on', 0) === 0)) { // lastIndexOf(,0)===0 -> startsWith\n          propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n          if (propName === 'oninput') {\n            (function() {\n              // record the evt.target.value, because IE sometimes does a requestAnimationFrame between changing value and running oninput\n              let oldPropValue = propValue;\n              propValue = function(evt: Event) {\n                (evt.target as any)['oninput-value'] = (evt.target as HTMLInputElement).value; // may be HTMLTextAreaElement as well\n                oldPropValue.apply(this, [evt]);\n              };\n            } ());\n          }\n        }\n        (domNode as any)[propName] = propValue;\n      } else if (type === 'string' && propName !== 'value') {\n        (domNode as Element).setAttribute(propName, propValue);\n      } else {\n        (domNode as any)[propName] = propValue;\n      }\n    }\n  }\n};\n\nlet updateProperties = function(domNode: Node, previousProperties: VNodeProperties, properties: VNodeProperties, projectionOptions: ProjectionOptions) {\n  if (!properties) {\n    return;\n  }\n  let propertiesUpdated = false;\n  let propNames = Object.keys(properties);\n  let propCount = propNames.length;\n  for (let i = 0; i < propCount; i++) {\n    let propName = propNames[i];\n    // assuming that properties will be nullified instead of missing is by design\n    let propValue = properties[propName];\n    let previousValue = previousProperties[propName];\n    if (propName === 'classes') {\n      let classList = (domNode as Element).classList;\n      let classNames = Object.keys(propValue);\n      let classNameCount = classNames.length;\n      for (let j = 0; j < classNameCount; j++) {\n        let className = classNames[j];\n        let on = !!propValue[className];\n        let previousOn = !!previousValue[className];\n        if (on === previousOn) {\n          continue;\n        }\n        propertiesUpdated = true;\n        if (on) {\n          classList.add(className);\n        } else {\n          classList.remove(className);\n        }\n      }\n    } else if (propName === 'styles') {\n      let styleNames = Object.keys(propValue);\n      let styleCount = styleNames.length;\n      for (let j = 0; j < styleCount; j++) {\n        let styleName = styleNames[j];\n        let newStyleValue = propValue[styleName];\n        let oldStyleValue = previousValue[styleName];\n        if (newStyleValue === oldStyleValue) {\n          continue;\n        }\n        propertiesUpdated = true;\n        if (newStyleValue) {\n          checkStyleValue(newStyleValue);\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, newStyleValue);\n        } else {\n          projectionOptions.styleApplyer(domNode as HTMLElement, styleName, '');\n        }\n      }\n    } else {\n      if (!propValue && typeof previousValue === 'string') {\n        propValue = '';\n      }\n      if (propName === 'value') { // value can be manipulated by the user directly and using event.preventDefault() is not an option\n        if ((domNode as any)[propName] !== propValue && (domNode as any)['oninput-value'] !== propValue) {\n          (domNode as any)[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n          (domNode as any)['oninput-value'] = undefined;\n        } // else do not update the domNode, otherwise the cursor position would be changed\n        if (propValue !== previousValue) {\n          propertiesUpdated = true;\n        }\n      } else if (propValue !== previousValue) {\n        let type = typeof propValue;\n        if (type === 'function') {\n          throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\n            '). Hint: declare event handler functions outside the render() function.');\n        }\n        if (type === 'string') {\n          (domNode as Element).setAttribute(propName, propValue);\n        } else {\n          if ((domNode as any)[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\n            (domNode as any)[propName] = propValue;\n          }\n        }\n        propertiesUpdated = true;\n      }\n    }\n  }\n  return propertiesUpdated;\n};\n\nlet findIndexOfChild = function(children: VNode[], sameAs: VNode, start: number) {\n  if (sameAs.vnodeSelector !== '') {\n    // Never scan for text-nodes\n    for (let i = start; i < children.length; i++) {\n      if (same(children[i], sameAs)) {\n        return i;\n      }\n    }\n  }\n  return -1;\n};\n\nlet nodeAdded = function(vNode: VNode, transitions: Transitions) {\n  if (vNode.properties) {\n    let enterAnimation = vNode.properties.enterAnimation;\n    if (enterAnimation) {\n      if (typeof enterAnimation === 'function') {\n        enterAnimation(vNode.domNode as Element, vNode.properties);\n      } else {\n        transitions.enter(vNode.domNode as Element, vNode.properties, enterAnimation as string);\n      }\n    }\n  }\n};\n\nlet nodeToRemove = function(vNode: VNode, transitions: Transitions) {\n  let domNode = vNode.domNode;\n  if (vNode.properties) {\n    let exitAnimation = vNode.properties.exitAnimation;\n    if (exitAnimation) {\n      (domNode as HTMLElement).style.pointerEvents = 'none';\n      let removeDomNode = function() {\n        if (domNode.parentNode) {\n          domNode.parentNode.removeChild(domNode);\n        }\n      };\n      if (typeof exitAnimation === 'function') {\n        exitAnimation(domNode as Element, removeDomNode, vNode.properties);\n        return;\n      } else {\n        transitions.exit(vNode.domNode as Element, vNode.properties, exitAnimation as string, removeDomNode);\n        return;\n      }\n    }\n  }\n  if (domNode.parentNode) {\n    domNode.parentNode.removeChild(domNode);\n  }\n};\n\nlet checkDistinguishable = function(childNodes: VNode[], indexToCheck: number, parentVNode: VNode, operation: string) {\n  let childNode = childNodes[indexToCheck];\n  if (childNode.vnodeSelector === '') {\n    return; // Text nodes need not be distinguishable\n  }\n  let key = childNode.properties ? childNode.properties.key : undefined;\n  if (!key) { // A key is just assumed to be unique\n    for (let i = 0; i < childNodes.length; i++) {\n      if (i !== indexToCheck) {\n        let node = childNodes[i];\n        if (same(node, childNode)) {\n          if (operation === 'added') {\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n              'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n          } else {\n            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n              'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n          }\n        }\n      }\n    }\n  }\n};\n\nlet createDom: (vnode: VNode, parentNode: Node, insertBefore: Node, projectionOptions: ProjectionOptions) => void;\nlet updateDom: (previous: VNode, vnode: VNode, projectionOptions: ProjectionOptions) => boolean;\n\nlet updateChildren = function(vnode: VNode, domNode: Node, oldChildren: VNode[], newChildren: VNode[], projectionOptions: ProjectionOptions) {\n  if (oldChildren === newChildren) {\n    return false;\n  }\n  oldChildren = oldChildren || emptyArray;\n  newChildren = newChildren || emptyArray;\n  let oldChildrenLength = oldChildren.length;\n  let newChildrenLength = newChildren.length;\n  let transitions = projectionOptions.transitions;\n\n  let oldIndex = 0;\n  let newIndex = 0;\n  let i: number;\n  let textUpdated = false;\n  while (newIndex < newChildrenLength) {\n    let oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\n    let newChild = newChildren[newIndex];\n    if (oldChild !== undefined && same(oldChild, newChild)) {\n      textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n      oldIndex++;\n    } else {\n      let findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n      if (findOldIndex >= 0) {\n        // Remove preceding missing children\n        for (i = oldIndex; i < findOldIndex; i++) {\n          nodeToRemove(oldChildren[i], transitions);\n          checkDistinguishable(oldChildren, i, vnode, 'removed');\n        }\n        textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n        oldIndex = findOldIndex + 1;\n      } else {\n        // New child\n        createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n        nodeAdded(newChild, transitions);\n        checkDistinguishable(newChildren, newIndex, vnode, 'added');\n      }\n    }\n    newIndex++;\n  }\n  if (oldChildrenLength > oldIndex) {\n    // Remove child fragments\n    for (i = oldIndex; i < oldChildrenLength; i++) {\n      nodeToRemove(oldChildren[i], transitions);\n      checkDistinguishable(oldChildren, i, vnode, 'removed');\n    }\n  }\n  return textUpdated;\n};\n\nlet addChildren = function(domNode: Node, children: VNode[], projectionOptions: ProjectionOptions) {\n  if (!children) {\n    return;\n  }\n  for (let i = 0; i < children.length; i++) {\n    createDom(children[i], domNode, undefined, projectionOptions);\n  }\n};\n\nlet initPropertiesAndChildren = function(domNode: Node, vnode: VNode, projectionOptions: ProjectionOptions) {\n  addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n  if (vnode.text) {\n    domNode.textContent = vnode.text;\n  }\n  setProperties(domNode, vnode.properties, projectionOptions);\n  if (vnode.properties && vnode.properties.afterCreate) {\n    vnode.properties.afterCreate(domNode as Element, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n  }\n};\n\ncreateDom = function(vnode, parentNode, insertBefore, projectionOptions) {\n  let domNode: Node, i: number, c: string, start = 0, type: string, found: string;\n  let vnodeSelector = vnode.vnodeSelector;\n  if (vnodeSelector === '') {\n    domNode = vnode.domNode = document.createTextNode(vnode.text);\n    if (insertBefore !== undefined) {\n      parentNode.insertBefore(domNode, insertBefore);\n    } else {\n      parentNode.appendChild(domNode);\n    }\n  } else {\n    for (i = 0; i <= vnodeSelector.length; ++i) {\n      c = vnodeSelector.charAt(i);\n      if (i === vnodeSelector.length || c === '.' || c === '#') {\n        type = vnodeSelector.charAt(start - 1);\n        found = vnodeSelector.slice(start, i);\n        if (type === '.') {\n          (domNode as HTMLElement).classList.add(found);\n        } else if (type === '#') {\n          (domNode as Element).id = found;\n        } else {\n          if (found === 'svg') {\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n          }\n          if (projectionOptions.namespace !== undefined) {\n            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n          } else {\n            domNode = vnode.domNode = document.createElement(found);\n          }\n          if (insertBefore !== undefined) {\n            parentNode.insertBefore(domNode, insertBefore);\n          } else {\n            parentNode.appendChild(domNode);\n          }\n        }\n        start = i + 1;\n      }\n    }\n    initPropertiesAndChildren(domNode, vnode, projectionOptions);\n  }\n};\n\nupdateDom = function(previous, vnode, projectionOptions) {\n  let domNode = previous.domNode;\n  if (!domNode) {\n    throw new Error('previous node was not rendered');\n  }\n  let textUpdated = false;\n  if (previous === vnode) {\n    return textUpdated; // we assume that nothing has changed\n  }\n  let updated = false;\n  if (vnode.vnodeSelector === '') {\n    if (vnode.text !== previous.text) {\n      domNode.nodeValue = vnode.text;\n      textUpdated = true;\n    }\n  } else {\n    if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\n      projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n    }\n    if (previous.text !== vnode.text) {\n      updated = true;\n      if (vnode.text === undefined) {\n        domNode.removeChild(domNode.firstChild); // the only textnode presumably\n      } else {\n        domNode.textContent = vnode.text;\n      }\n    }\n    updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n    updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n    if (vnode.properties && vnode.properties.afterUpdate) {\n      vnode.properties.afterUpdate(<Element>domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n    }\n  }\n  if (updated && vnode.properties && vnode.properties.updateAnimation) {\n    vnode.properties.updateAnimation(<Element>domNode, vnode.properties, previous.properties);\n  }\n  vnode.domNode = previous.domNode;\n  return textUpdated;\n};\n\n/**\n * Represents a {@link VNode} tree that has been rendered to a real DOM tree.\n * @interface Projection\n */\nlet createProjection = function(vnode: VNode, projectionOptions: ProjectionOptions): Projection {\n  if (!vnode.vnodeSelector) {\n    throw new Error('Invalid vnode argument');\n  }\n  return {\n    /**\n     * Updates the projection with the new virtual DOM tree.\n     * @param {VNode} updatedVnode - The updated virtual DOM tree. Note: The selector for the root of the tree must remain constant.\n     * @memberof Projection#\n     */\n    update: function(updatedVnode: VNode) {\n      if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n        throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n      }\n      updateDom(vnode, updatedVnode, projectionOptions);\n      vnode = updatedVnode;\n    },\n    /**\n     * The DOM node that is used as the root of this {@link Projection}.\n     * @type {Element}\n     * @memberof Projection#\n     */\n    domNode: <Element>vnode.domNode\n  };\n};\n\n// Declaration of interfaces and callbacks, before the @exports maquette\n\n/**\n * A CalculationCache object remembers the previous outcome of a calculation along with the inputs.\n * On subsequent calls the previous outcome is returned if the inputs are identical.\n * This object can be used to bypass both rendering and diffing of a virtual DOM subtree.\n * Instances of {@link CalculationCache} can be created using {@link module:maquette.createCache}.\n * @interface CalculationCache\n */\n\n/**\n * Keeps an array of result objects synchronized with an array of source objects.\n * Mapping provides a {@link Mapping#map} function that updates the {@link Mapping#results}.\n * The {@link Mapping#map} function can be called multiple times and the results will get created, removed and updated accordingly.\n * A {@link Mapping} can be used to keep an array of components (objects with a `renderMaquette` method) synchronized with an array of data.\n * Instances of {@link Mapping} can be created using {@link module:maquette.createMapping}.\n * @interface Mapping\n */\n\n/**\n * Used to create and update the DOM.\n * Use {@link Projector#append}, {@link Projector#merge}, {@link Projector#insertBefore} and {@link Projector#replace}\n * to create the DOM.\n * The `renderMaquetteFunction` callbacks will be called immediately to create the DOM. Afterwards, these functions\n * will be called again to update the DOM on the next animation-frame after:\n *\n *  - The {@link Projector#scheduleRender} function  was called\n *  - An event handler (like `onclick`) on a rendered {@link VNode} was called.\n *\n * The projector stops when {@link Projector#stop} is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of {@link Projector} can be created using {@link module:maquette.createProjector}.\n * @interface Projector\n */\n\n/**\n * @callback enterAnimationCallback\n * @param {Element} element - Element that was just added to the DOM.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method\n */\n\n/**\n * @callback exitAnimationCallback\n * @param {Element} element - Element that ought to be removed from to the DOM.\n * @param {function(Element)} removeElement - Function that removes the element from the DOM.\n * This argument is supplied purely for convenience.\n * You may use this function to remove the element when the animation is done.\n * @param {Object} properties - The properties object that was supplied to the {@link module:maquette.h} method that rendered this {@link VNode}\n * the previous time.\n */\n\n/**\n * @callback updateAnimationCallback\n * @param {Element} element - Element that was modified in the DOM.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n\n/**\n * @callback afterCreateCallback\n * @param {Element} element - The element that was added to the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children that were created.\n * @param {Object} properties - The last properties object that was supplied to the {@link module:maquette.h} method\n * @param {Object} previousProperties - The previous properties object that was supplied to the {@link module:maquette.h} method\n */\n\n/**\n * @callback afterUpdateCallback\n * @param {Element} element - The element that may have been updated in the DOM.\n * @param {Object} projectionOptions - The projection options that were used see {@link module:maquette.createProjector}.\n * @param {string} vnodeSelector - The selector passed to the {@link module:maquette.h} function.\n * @param {Object} properties - The properties passed to the {@link module:maquette.h} function.\n * @param {VNode[]} children - The children for this node.\n */\n\n/**\n * Contains simple low-level utility functions to manipulate the real DOM. The singleton instance is available under {@link module:maquette.dom}.\n * @interface MaquetteDom\n */\n\n/**\n * The `h` method is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * @param {string} selector - Contains the tagName, id and fixed css classnames in CSS selector format.\n * It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n * @param {Object} [properties] - An object literal containing properties that will be placed on the DOM node.\n * @param {function} properties.<b>*</b> - Properties with functions values like `onclick:handleClick` are registered as event handlers\n * @param {String} properties.<b>*</b> - Properties with string values, like `href:'/'` are used as attributes\n * @param {object} properties.<b>*</b> - All non-string values are put on the DOM node as properties\n * @param {Object} properties.key - Used to uniquely identify a DOM node among siblings.\n * A key is required when there are more children with the same selector and these children are added or removed dynamically.\n * @param {Object} properties.classes - An object literal like `{important:true}` which allows css classes, like `important` to be added and removed\n * dynamically.\n * @param {Object} properties.styles - An object literal like `{height:'100px'}` which allows styles to be changed dynamically. All values must be strings.\n * @param {(string|enterAnimationCallback)} properties.enterAnimation - The animation to perform when this node is added to an already existing parent.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * @param {(string|exitAnimationCallback)} properties.exitAnimation - The animation to perform when this node is removed while its parent remains.\n * When this value is a string, you must pass a `projectionOptions.transitions` object when creating the projector {@link module:maquette.createProjector}.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {updateAnimationCallback} properties.updateAnimation - The animation to perform when the properties of this node change.\n * This also includes attributes, styles, css classes. This callback is also invoked when node contains only text and that text changes.\n * {@link http://maquettejs.org/docs/animations.html|More about animations}.\n * @param {afterCreateCallback} properties.afterCreate - Callback that is executed after this node is added to the DOM. Childnodes and properties have\n * already been applied.\n * @param {afterUpdateCallback} properties.afterUpdate - Callback that is executed every time this node may have been updated. Childnodes and properties\n * have already been updated.\n * @param {Object[]} [children] - An array of virtual DOM nodes to add as child nodes.\n * This array may contain nested arrays, `null` or `undefined` values.\n * Nested arrays are flattened, `null` and `undefined` will be skipped.\n *\n * @returns {VNode} A VNode object, used to render a real DOM later.\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|three basic rules} you should be aware of when updating the virtual DOM.\n */\nexport let h = function(selector: string /*, ...propertiesAndChildren */): VNode {\n  let properties = arguments[1];\n  if (typeof selector !== 'string') {\n    throw new Error();\n  }\n  let childIndex = 1;\n  if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n    childIndex = 2;\n  } else {\n    // Optional properties argument was omitted\n    properties = undefined;\n  }\n  let text = undefined as string;\n  let children = undefined as VNode[];\n  let argsLength = arguments.length;\n  // Recognize a common special case where there is only a single text node\n  if (argsLength === childIndex + 1) {\n    let onlyChild = arguments[childIndex];\n    if (typeof onlyChild === 'string') {\n      text = onlyChild;\n    } else if (onlyChild !== undefined && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n      text = onlyChild[0];\n    }\n  }\n  if (text === undefined) {\n    children = [];\n    for (; childIndex < arguments.length; childIndex++) {\n      let child = arguments[childIndex];\n      if (child === null || child === undefined) {\n        continue;\n      } else if (Array.isArray(child)) {\n        appendChildren(selector, child, children);\n      } else if (child.hasOwnProperty('vnodeSelector')) {\n        children.push(child);\n      } else {\n        children.push(toTextVNode(child));\n      }\n    }\n  }\n  return {\n    vnodeSelector: selector,\n    properties: properties,\n    children: children,\n    text: text,\n    domNode: null\n  };\n};\n\n/**\n * @type MaquetteDom\n */\nexport let dom = {\n  /**\n   * Creates a real DOM tree from a {@link VNode}. The {@link Projection} object returned will contain the resulting DOM Node under\n   * the {@link Projection#domNode} property.\n   * This is a low-level method. Users wil typically use a {@link Projector} instead.\n   * @memberof MaquetteDom#\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode}\n   * objects may only be rendered once.\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n   * @returns {Projection} The {@link Projection} which contains the DOM Node that was created.\n   */\n  create: function(vnode: VNode, projectionOptions: ProjectionOptions) {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Appends a new childnode to the DOM which is generated from a {@link VNode}.\n   * This is a low-level method. Users wil typically use a {@link Projector} instead.\n   * @memberof MaquetteDom#\n   * @param {Element} parentNode - The parent node for the new childNode.\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode}\n   * objects may only be rendered once.\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n   * @returns {Projection} The {@link Projection} that was created.\n   */\n  append: function(parentNode: Element, vnode: VNode, projectionOptions: ProjectionOptions) {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, parentNode, undefined, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Inserts a new DOM node which is generated from a {@link VNode}.\n   * This is a low-level method. Users wil typically use a {@link Projector} instead.\n   * @memberof MaquetteDom#\n   * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function.\n   * NOTE: {@link VNode} objects may only be rendered once.\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n   * @returns {Projection} The {@link Projection} that was created.\n   */\n  insertBefore: function(beforeNode: Element, vnode: VNode, projectionOptions: ProjectionOptions) {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  },\n\n  /**\n   * Merges a new DOM node which is generated from a {@link VNode} with an existing DOM Node.\n   * This means that the virtual DOM and real DOM have one overlapping element.\n   * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n   * This is a low-level method. Users wil typically use a {@link Projector} instead.\n   * @memberof MaquetteDom#\n   * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n   * @param {VNode} vnode - The root of the virtual DOM tree that was created using the {@link module:maquette.h} function. NOTE: {@link VNode} objects\n   * may only be rendered once.\n   * @param {Object} projectionOptions - Options to be used to create and update the projection, see {@link module:maquette.createProjector}.\n   * @returns {Projection} The {@link Projection} that was created.\n   */\n  merge: function(element: Element, vnode: VNode, projectionOptions: ProjectionOptions) {\n    projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n    vnode.domNode = element;\n    initPropertiesAndChildren(element, vnode, projectionOptions);\n    return createProjection(vnode, projectionOptions);\n  }\n};\n\n/**\n * Creates a {@link CalculationCache} object, useful for caching {@link VNode} trees.\n * In practice, caching of {@link VNode} trees is not needed, because achieving 60 frames per second is almost never a problem.\n * @returns {CalculationCache}\n */\nexport let createCache = function() {\n  let cachedInputs = undefined as Object[];\n  let cachedOutcome = undefined as Object;\n  let result = {\n    /**\n     * Manually invalidates the cached outcome.\n     * @memberof CalculationCache#\n     */\n    invalidate: function() {\n      cachedOutcome = undefined;\n      cachedInputs = undefined;\n    },\n    /**\n     * If the inputs array matches the inputs array from the previous invocation, this method returns the result of the previous invocation.\n     * Otherwise, the calculation function is invoked and its result is cached and returned.\n     * Objects in the inputs array are compared using ===.\n     * @param {Object[]} inputs - Array of objects that are to be compared using === with the inputs from the previous invocation.\n     * These objects are assumed to be immutable primitive values.\n     * @param {function} calculation - Function that takes zero arguments and returns an object (A {@link VNode} assumably) that can be cached.\n     * @memberof CalculationCache#\n     */\n    result: function(inputs: Object[], calculation: () => Object) {\n      if (cachedInputs) {\n        for (let i = 0; i < inputs.length; i++) {\n          if (cachedInputs[i] !== inputs[i]) {\n            cachedOutcome = undefined;\n          }\n        }\n      }\n      if (!cachedOutcome) {\n        cachedOutcome = calculation();\n        cachedInputs = inputs;\n      }\n      return cachedOutcome;\n    }\n  };\n  return result;\n};\n\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * @param {function} getSourceKey - `function(source)` that must return a key to identify each source object. The result must eather be a string or a number.\n * @param {function} createResult - `function(source, index)` that must create a new result object from a given source. This function is identical\n * argument of `Array.map`.\n * @param {function} updateResult - `function(source, target, index)` that updates a result to an updated source.\n * @returns {Mapping}\n */\nexport let createMapping = function(\n  getSourceKey: (source: Object) => Object,\n  createResult: (source: Object, index: number) => Object,\n  updateResult: (source: Object, target: Object, index: number) => void\n  /*, deleteTarget*/) {\n  let keys = [] as Object[];\n  let results = [] as  Object[];\n\n  return {\n    /**\n     * The array of results. These results will be synchronized with the latest array of sources that were provided using {@link Mapping#map}.\n     * @type {Object[]}\n     * @memberof Mapping#\n     */\n    results: results,\n    /**\n     * Maps a new array of sources and updates {@link Mapping#results}.\n     * @param {Object[]} newSources - The new array of sources.\n     * @memberof Mapping#\n     */\n    map: function(newSources: Object[]) {\n      let newKeys = newSources.map(getSourceKey);\n      let oldTargets = results.slice();\n      let oldIndex = 0;\n      for (let i = 0; i < newSources.length; i++) {\n        let source = newSources[i];\n        let sourceKey = newKeys[i];\n        if (sourceKey === keys[oldIndex]) {\n          results[i] = oldTargets[oldIndex];\n          updateResult(source, oldTargets[oldIndex], i);\n          oldIndex++;\n        } else {\n          let found = false;\n          for (let j = 1; j < keys.length; j++) {\n            let searchIndex = (oldIndex + j) % keys.length;\n            if (keys[searchIndex] === sourceKey) {\n              results[i] = oldTargets[searchIndex];\n              updateResult(newSources[i], oldTargets[searchIndex], i);\n              oldIndex = searchIndex + 1;\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            results[i] = createResult(source, i);\n          }\n        }\n      }\n      results.length = newSources.length;\n      keys = newKeys;\n    }\n  };\n};\n\n/**\n * Creates a {@link Projector} instance using the provided projectionOptions.\n * @param {Object} [projectionOptions] - Options that influence how the DOM is rendered and updated.\n * @param {Object} projectionOptions.transitions - A transition strategy to invoke when\n * enterAnimation and exitAnimation properties are provided as strings.\n * The module `cssTransitions` in the provided `css-transitions.js` file provides such a strategy.\n * A transition strategy is not needed when enterAnimation and exitAnimation properties are provided as functions.\n * @returns {Projector}\n */\nexport let createProjector = function(projectionOptions: ProjectionOptions) {\n  let projector: Projector;\n  projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n  projectionOptions.eventHandlerInterceptor = function(propertyName: string, functionPropertyArgument: Function) {\n    return function() {\n      // intercept function calls (event handlers) to do a render afterwards.\n      projector.scheduleRender();\n      return functionPropertyArgument.apply(this, arguments);\n    };\n  };\n  let renderCompleted = true;\n  let scheduled: number;\n  let stopped = false;\n  let projections = [] as Projection[];\n  let renderFunctions = [] as (() => VNode)[]; // matches the projections array\n\n  let doRender = function() {\n    scheduled = undefined;\n    if (!renderCompleted) {\n      return; // The last render threw an error, it should be logged in the browser console.\n    }\n    renderCompleted = false;\n    for (let i = 0; i < projections.length; i++) {\n      let updatedVnode = renderFunctions[i]();\n      projections[i].update(updatedVnode);\n    }\n    renderCompleted = true;\n  };\n\n  projector = {\n    /**\n     * Instructs the projector to re-render to the DOM at the next animation-frame using the registered `renderMaquette` functions.\n     * This method is automatically called for you when event-handlers that are registered in the {@link VNode}s are invoked.\n     * You need to call this method for instance when timeouts expire or AJAX responses arrive.\n     * @memberof Projector#\n     */\n    scheduleRender: function() {\n      if (!scheduled && !stopped) {\n        scheduled = requestAnimationFrame(doRender);\n      }\n    },\n    /**\n     * Stops the projector. This means that the registered `renderMaquette` functions will not be called anymore.\n     * Note that calling {@link Projector#stop} is not mandatory. A projector is a passive object that will get garbage collected as usual\n     * if it is no longer in scope.\n     * @memberof Projector#\n     */\n    stop: function() {\n      if (scheduled) {\n        cancelAnimationFrame(scheduled);\n        scheduled = undefined;\n      }\n      stopped = true;\n    },\n\n    /**\n     * Resumes the projector. Use this method to resume rendering after stop was called or an error occurred during rendering.\n     * @memberof Projector#\n     */\n    resume: function() {\n      stopped = false;\n      renderCompleted = true;\n      projector.scheduleRender();\n    },\n\n    /**\n     * Appends a new childnode to the DOM using the result from the provided `renderMaquetteFunction`.\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n     * @param {Element} parentNode - The parent node for the new childNode.\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n     * @memberof Projector#\n     */\n    append: function(parentNode, renderMaquetteFunction) {\n      projections.push(dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    /**\n     * Inserts a new DOM node using the result from the provided `renderMaquetteFunction`.\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n     * @param {Element} beforeNode - The node that the DOM Node is inserted before.\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n     * @memberof Projector#\n     */\n    insertBefore: function(beforeNode, renderMaquetteFunction) {\n      projections.push(dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    /**\n     * Merges a new DOM node using the result from the provided `renderMaquetteFunction` with an existing DOM Node.\n     * This means that the virtual DOM and real DOM have one overlapping element.\n     * Therefore the selector for the root {@link VNode} will be ignored, but its properties and children will be applied to the Element provided\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n     * @param {Element} domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n     * @memberof Projector#\n     */\n    merge: function(domNode, renderMaquetteFunction) {\n      projections.push(dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    },\n\n    /**\n     * Replaces an existing DOM node with the result from the provided `renderMaquetteFunction`.\n     * The `renderMaquetteFunction` will be invoked again to update the DOM when needed.\n     * @param {Element} domNode - The DOM node to replace.\n     * @param {function} renderMaquetteFunction - Function with zero arguments that returns a {@link VNode} tree.\n     * @memberof Projector#\n     */\n    replace: function(domNode, renderMaquetteFunction) {\n      let vnode = renderMaquetteFunction();\n      createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n      domNode.parentNode.removeChild(domNode);\n      projections.push(createProjection(vnode, projectionOptions));\n      renderFunctions.push(renderMaquetteFunction);\n    }\n  };\n  return projector;\n};\n"],"sourceRoot":"/source/"}